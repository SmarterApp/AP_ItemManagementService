package org.opentestsystem.ap.ims.service;

import com.google.common.collect.ImmutableSet;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.security.authentication.TestingAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import org.opentestsystem.ap.common.bulkupdate.BulkUpdateService;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.exception.ValidationException;
import org.opentestsystem.ap.common.itembank.AttachmentValidator;
import org.opentestsystem.ap.common.management.ItemManager;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.GiItem;
import org.opentestsystem.ap.common.model.GiItemCore;
import org.opentestsystem.ap.common.model.ItemResponse;
import org.opentestsystem.ap.common.model.ItemTransaction;
import org.opentestsystem.ap.common.model.content.GiItemContent;
import org.opentestsystem.ap.common.security.SecurityUtil;
import org.opentestsystem.ap.common.security.model.ItemBankUser;
import org.opentestsystem.ap.ims.TestUtil;
import org.opentestsystem.ap.ims.model.UploadFile;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.common.model.ModelConstants.Section.SECTION_CORE;

@RunWith(MockitoJUnitRunner.class)
public class AttachmentServiceTest {
    private static final String ItemId = "1234";

    @Rule
    public TemporaryFolder temporaryFolder = new TemporaryFolder();

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Mock
    private ItemManager itemManager;

    @Mock
    private BulkUpdateService bulkUpdateService;

    @Mock
    private DataStoreAttachmentManager attachmentManager;

    @Mock
    private AttachmentValidator attachmentValidator;

    @InjectMocks
    private AttachmentService service;

    private TestUtil testUtil;
    private ItemBankUser user;

    @Before
    public void setup() {
        testUtil = new TestUtil();

        final GiItemContent content = new GiItemContent();

        final GiItemCore core = new GiItemCore();
        core.setEn(content);

        final GiItem item = new GiItem(ItemId);
        item.setCore(core);

        SecurityContextHolder.getContext()
                .setAuthentication(new TestingAuthenticationToken(testUtil.user(), null));
        user = SecurityUtil.getItemBankUser();

        final ItemResponse response = new ItemResponse();
        response.setItem(item);
        when(itemManager.findItem(user, ItemId)).thenReturn(response);

        final ItemTransaction transaction = ItemTransaction.builder()
                .commitId(UUID.randomUUID())
                .section(SECTION_CORE)
                .userName(user.getUserName())
                .build();
        when(itemManager.findUserTransaction(user, ItemId)).thenReturn(transaction);
    }

    @Test
    public void itShouldThrowIfUserNotEditing() throws Exception {
        when(itemManager.findUserTransaction(any(), any())).thenReturn(null);

        thrown.expect(ValidationException.class);
        thrown.expectMessage("File upload not allowed, you must be editing a section.");

        service.saveGiArchive(uploadFile(archive(gaxFile(Collections.emptySet()))));
    }

    @Test
    public void itShouldUploadAGiArchiveWithoutResources() throws Exception {

        final GiItemContent content = service.saveGiArchive(uploadFile(archive(gaxFile(Collections.emptySet()))));

        assertThat(content.getContentZipFile().getFileName()).isEqualTo("original_name.zip");
        assertThat(content.getGiDefinition()).isNotBlank();

        verify(attachmentManager).saveAttachment(eq(ItemId), eq(SECTION_CORE), eq("original_name.zip"), any());
    }

    @Test
    public void itShouldUploadAGiArchiveWithResources() throws Exception {
        final Path resourceA = resourceFile("resource-a.png");
        final Path resourceB = resourceFile("resource-b.png");
        final Path gaxResource = gaxFile(ImmutableSet.of("resource-a.png", "resource-b.png"));

        final GiItemContent content = service.saveGiArchive(uploadFile(archive(gaxResource, resourceA, resourceB)));

        assertThat(content.getGiResources().stream().map(Attachment::getFileName).collect(Collectors.toList()))
                .containsOnly("resource-a.png", "resource-b.png");

        verify(attachmentManager).saveAttachment(eq(ItemId), eq(SECTION_CORE), eq("original_name.zip"), any());
        verify(attachmentManager).saveAttachment(eq(ItemId), eq(SECTION_CORE), eq("resource-a.png"), any());
        verify(attachmentManager).saveAttachment(eq(ItemId), eq(SECTION_CORE), eq("resource-b.png"), any());
    }

    @Test
    public void itShouldThrowIfReferencedResourceNotIncluded() throws Exception {
        final Path resourceA = resourceFile("resource-a.png");
        final Path gaxResource = gaxFile(ImmutableSet.of("resource-a.png", "resource-b.png"));

        thrown.expect(ValidationException.class);
        thrown.expectMessage("GAX references missing resource: resource-b.png");

        service.saveGiArchive(uploadFile(archive(gaxResource, resourceA)));
    }

    @Test
    public void itShouldIncludeTranslationOverrideResources() throws Exception {
        final Path resourceA = resourceFile("resource-a.png");
        final Path resourceASpanish = resourceFile("resource-a_ESN.png");
        final Path resourceB = resourceFile("resource-b.png");
        final Path gaxResource = gaxFile(ImmutableSet.of("resource-a.png", "resource-b.png"));

        final GiItemContent content = service.saveGiArchive(uploadFile(archive(gaxResource, resourceA, resourceASpanish, resourceB)));

        assertThat(content.getGiResources().stream().map(Attachment::getFileName).collect(Collectors.toList()))
                .containsOnly("resource-a.png", "resource-a_ESN.png", "resource-b.png");
        verify(attachmentManager).saveAttachment(eq(ItemId), eq(SECTION_CORE), eq("resource-a_ESN.png"), any());
    }

    @Test
    public void itShouldIgnoreNonReferencedResources() throws Exception {
        final Path resourceA = resourceFile("resource-a.png");
        final Path resourceB = resourceFile("resource-b.png");
        final Path gaxResource = gaxFile(ImmutableSet.of("resource-a.png"));

        final GiItemContent content = service.saveGiArchive(uploadFile(archive(gaxResource, resourceA, resourceB)));
        assertThat(content.getGiResources().stream().map(Attachment::getFileName).collect(Collectors.toList()))
                .containsOnly("resource-a.png");
        verify(attachmentManager, never()).saveAttachment(eq(ItemId), eq(SECTION_CORE), eq("resource-b.png"), any());
    }

    @Test
    public void itShouldThrowIfUploadDoesNotContainGaxFile() throws Exception {
        final Path resourceA = resourceFile("resource-a.png");

        thrown.expect(ValidationException.class);
        thrown.expectMessage("GI Archive must contain one and only one .gax GI definition XML file");

        service.saveGiArchive(uploadFile(archive(resourceA)));
    }

    @Test
    public void itShouldThrowIfUploadContainsMultipleGaxFiles() throws Exception {
        final Path resourceA = resourceFile("additional.gax");
        final Path gaxResource = gaxFile(ImmutableSet.of());

        thrown.expect(ValidationException.class);
        thrown.expectMessage("GI Archive must contain one and only one .gax GI definition XML file");

        service.saveGiArchive(uploadFile(archive(gaxResource, resourceA)));
    }

    @Test
    public void itShouldThrowIfUploadContainsInvalidGaxFile() throws Exception {
        final Path resourceA = resourceFile("bad.gax");

        thrown.expect(ValidationException.class);
        thrown.expectMessage("Problem parsing filenames from gax file");

        service.saveGiArchive(uploadFile(archive(resourceA)));
    }

    private UploadFile uploadFile(final Path archive) throws IOException {
        final UploadFile uploadFile = new UploadFile();
        uploadFile.setItemId(ItemId);
        uploadFile.setSection(SECTION_CORE);
        final MockMultipartFile mockFile = new MockMultipartFile(
                "upload_name.zip",
                "original_name.zip",
                "application/zip",
                Files.readAllBytes(archive));
        uploadFile.setFile(mockFile);
        return uploadFile;
    }

    private Path gaxFile(final Set<String> resources) throws IOException {
        final StringBuilder gaxContent = new StringBuilder("<Question id=\"1234\" ITSVer=\"0\" ScoreEngineVer=\"1\" version=\"2.0\" xmlns=\"\">\n")
                .append("<Description/>\n")
                .append("<QuestionPart id=\"1\">\n")
                .append("<Text/>\n")
                .append("<ObjectMenuIcons/>\n");

        resources.forEach(filename -> gaxContent.append("<ImageSpec>\n")
                .append("<FileSpec>").append(filename).append("</FileSpec>\n")
                .append("<Position>0,0</Position>\n")
                .append("</ImageSpec>\n"));

        gaxContent.append("</QuestionPart>\n")
                .append("<PreSetAnswerPart>\n")
                .append("<AnswerSet>\n")
                .append("<Question id=\"1234\">\n")
                .append("<QuestionPart id=\"1\">\n")
                .append("<ObjectSet/>\n")
                .append("<SnapPoint/>\n")
                .append("</QuestionPart>\n")
                .append("</Question>\n")
                .append("</AnswerSet>\n")
                .append("</PreSetAnswerPart>\n")
                .append("</Question>");

        final Path gaxFile = temporaryFolder.newFile("test.gax").toPath();
        Files.write(gaxFile, gaxContent.toString().getBytes(StandardCharsets.UTF_8));

        return gaxFile;
    }

    private Path resourceFile(final String filename) throws IOException {
        final Path resourceFile = temporaryFolder.newFile(filename).toPath();
        Files.write(resourceFile, filename.getBytes(StandardCharsets.UTF_8));

        return resourceFile;
    }

    private Path archive(final Path ...contents) throws IOException {
        final Path archiveFile = temporaryFolder.newFile("original_name.zip").toPath();
        try (final ArchiveOutputStream outputStream = new ZipArchiveOutputStream(archiveFile.toFile())) {
            for (final Path content : contents) {
                final ArchiveEntry entry = outputStream.createArchiveEntry(content.toFile(), content.getFileName().toString());
                outputStream.putArchiveEntry(entry);
                try (final InputStream contentStream = Files.newInputStream(content)) {
                    IOUtils.copy(contentStream, outputStream);
                }
                outputStream.closeArchiveEntry();
            }
            outputStream.finish();
        }
        return archiveFile;
    }
}