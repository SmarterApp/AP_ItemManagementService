/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.opentestsystem.ap.common.bulkupdate.BulkUpdateService;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.exception.ValidationException;
import org.opentestsystem.ap.common.itembank.AttachmentValidator;
import org.opentestsystem.ap.common.management.ItemManager;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.AttachmentRequest;
import org.opentestsystem.ap.common.model.GiItem;
import org.opentestsystem.ap.common.model.ItemTransaction;
import org.opentestsystem.ap.common.model.ModelConstants;
import org.opentestsystem.ap.common.model.attachment.AttachmentSelector;
import org.opentestsystem.ap.common.model.content.GiItemContent;
import org.opentestsystem.ap.common.security.SecurityUtil;
import org.opentestsystem.ap.common.security.model.ItemBankUser;
import org.opentestsystem.ap.common.util.ZipUtil;
import org.opentestsystem.ap.ims.model.UploadFile;

import static java.lang.String.format;
import static org.apache.commons.io.FileUtils.deleteQuietly;
import static org.apache.commons.io.FilenameUtils.removeExtension;

/**
 * Handles file requests like uploading, downloading, and retrieving item files.
 */
@Slf4j
@Service
public class AttachmentService {
    private static final Pattern TRANSLATED_RESOURCE_FILENAME = Pattern.compile("^(.+)_(.+?)$");
    private static final String BULK_PREVIEW_FILE_DELIMITER = ",";

    private final ItemManager itemManager;
    private final BulkUpdateService bulkUpdateService;
    private final DataStoreAttachmentManager attachmentManager;
    private final AttachmentValidator attachmentValidator;

    public AttachmentService(final ItemManager itemManager,
                             final BulkUpdateService bulkUpdateService,
                             final DataStoreAttachmentManager attachmentManager,
                             final AttachmentValidator attachmentValidator) {
        this.itemManager = itemManager;
        this.bulkUpdateService = bulkUpdateService;
        this.attachmentManager = attachmentManager;
        this.attachmentValidator = attachmentValidator;
    }

    // ------------------------------------------------------------------------

    /**
     * Validates, processes, and uploads the given GI ZIP archive
     * containing a .GAX grid item definition XML and required
     * resources (images.)
     *
     * @param archiveUpload The uploaded GI archive
     * @return  The updated GiItemContent referencing the uploaded GI archive resource(s)
     */
    public GiItemContent saveGiArchive(final UploadFile archiveUpload) {
        archiveUpload.validate();

        final ItemBankUser user = SecurityUtil.getItemBankUser();
        final GiItem item = (GiItem) itemManager.findItem(user, archiveUpload.getItemId()).getItem();
        final GiItemContent contentModel = item.getCore().getEn();

        final ItemTransaction userTransaction = itemManager.findUserTransaction(user, archiveUpload.getItemId());
        if (Objects.isNull(userTransaction)) {
            throw new ValidationException("File upload not allowed, you must be editing a section.");
        }

        Path giArchive = null;
        Path giContents = null;

        try {
            giArchive = Files.createTempFile("gi-archive", "zip");
            archiveUpload.getFile().transferTo(giArchive.toFile());

            // Upload archive zip
            // TODO: remove this if/when GI logic no longer relies on zip archive
            contentModel.setContentZipFile(uploadCoreFile(
                    archiveUpload.getItemId(),
                    userTransaction.getSection(),
                    archiveUpload.getFile().getOriginalFilename(),
                    giArchive));

            // Unzip, validate, and upload gi archive contents
            giContents = Files.createTempDirectory("gi-contents");
            ZipUtil.unzip(giArchive, giContents);

            final Map<String, Path> uploadedResources = FileUtils.listFiles(giContents.toFile(),null,false).stream()
                    .collect(Collectors.toMap(
                            File::getName,
                            File::toPath
                    ));

            final Path gaxFile = findGaxFile(uploadedResources);

            // Save GAX / GI definition in item.json
            try (final InputStream gaxStream = Files.newInputStream(gaxFile)) {
                contentModel.setGiDefinition(IOUtils.toString(gaxStream, StandardCharsets.UTF_8).trim());
            }

            // Validate and upload GAX-referenced resources
            final List<String> referencedFilenames = AttachmentSelector.getReferencedGaxFileNames(gaxFile.toFile());
            final List<Path> referencedResources = findGaxResources(referencedFilenames, uploadedResources);

            // Include translated GAX resource overrides
            // TODO These should probably be represented by the UI and model as translation resource overrides
            //  rather than reply on zip-contents file-naming conventions.
            referencedResources.addAll(findGaxTranslatedResources(referencedFilenames, uploadedResources));

            // Upload associated resources
            final List<Attachment> attachments = referencedResources.stream()
                    .map(resource -> uploadCoreFile(
                            archiveUpload.getItemId(),
                            userTransaction.getSection(),
                            resource.getFileName().toString(),
                            resource
                    ))
                    .collect(Collectors.toList());

            contentModel.setGiResources(attachments);

            return contentModel;
        } catch (final IOException e) {
            throw new IllegalStateException(format("Problem uploading GI Archive for item: %s", archiveUpload.getItemId()), e);
        } finally {
            if (giArchive != null) {
                deleteQuietly(giArchive.toFile());
            }
            if (giContents != null) {
                deleteQuietly(giContents.toFile());
            }
        }
    }

    /**
     * Validates and processes the file upload request.
     *
     * @param uploadFile The upload request holding information like item ID, transaction ID, and the file(s).
     */
    @Transactional
    public void saveAttachment(UploadFile uploadFile) {
        uploadFile.validate();

        String itemId = uploadFile.getItemId();
        MultipartFile file = uploadFile.getFile();

        log.debug("Saving attachment {} for item {}", file.getOriginalFilename(), itemId);

        AttachmentRequest attachmentRequest = uploadFile.newAttachmentRequest();

        itemManager.saveAttachment(SecurityUtil.getItemBankUser(), itemId, attachmentRequest, file);
    }

    @Transactional(readOnly = true)
    public InputStream getAttachment(String itemId, String fileName) {
        return this.itemManager.getAttachment(SecurityUtil.getItemBankUser(), itemId, fileName);
    }

    public List<String> findAttachments(String itemid, String branch) {
        return this.itemManager.findAttachments(SecurityUtil.getItemBankUser(), itemid, branch);
    }

    // ------------------------------------------------------------------------

    /**
     * Reads an uploaded text file. Replaces carriage returns with comma delimiter
     *
     * @param uploadFile
     * @return comma delimited string
     */
    // TODO: IAT-1772 - Remove after item search dashboard implemented
    public String convertBulkPreviewFile(final UploadFile uploadFile) {
        log.debug("Converting bulk preview file");
        String content = "";
        try {
            content = new String(uploadFile.getFile().getBytes(), "UTF-8");
        } catch (Exception ex) {
            log.error("Error reading bulk preview file", ex);
        }

        content = content.replace(" ", "");
        content = content.replace("\n", BULK_PREVIEW_FILE_DELIMITER);
        if (content.length() > 0 && content.charAt(content.length() - 1) == ',') {
            content = content.substring(0, content.length() - 1);
        }

        return content;
    }

    /**
     * Returns bytes of uploaded file.
     *
     * @param uploadFile
     * @return
     */
    public String readFileContents(final UploadFile uploadFile) {
        try {
            return new String(uploadFile.getFile().getBytes(), "UTF-8");
        } catch (Exception ex) {
            log.error("Error reading file contents", ex);
            return "";
        }
    }

    /**
     * Bulk updates Test Administration data for multiple items.
     *
     * @param uploadFile
     */
    public void processTestAdministrationData(final UploadFile uploadFile) {
        log.debug("Uploading file to bulk upload test administration data ");
        this.bulkUpdateService.processTestAdministrationData(SecurityUtil.getItemBankUser(), uploadFile.getFile());
    }

    private Attachment uploadCoreFile(final String itemId, final String section, final String filename, final Path file) {
        attachmentValidator.validateFileNameDoesNotHaveIllegalCharacters(filename);
        attachmentManager.saveAttachment(itemId, section, filename, file);
        return new Attachment(
                filename,
                new Date(),
                ModelConstants.Section.SECTION_CORE
        );
    }

    private Path findGaxFile(final Map<String, Path> contentsByFilename) {
        final List<Path> gaxFiles = contentsByFilename.entrySet().stream()
                .filter(entry -> FilenameUtils.isExtension(entry.getKey(), "gax"))
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
        if (gaxFiles.size() != 1) {
            throw new ValidationException("GI Archive must contain one and only one .gax GI definition XML file");
        }
        return gaxFiles.get(0);
    }

    private List<Path> findGaxResources(final Collection<String> resourceNames, final Map<String, Path> contentsByFilename) {
        return resourceNames.stream()
                .map(referencedFilename -> {
                    if (!contentsByFilename.containsKey(referencedFilename)) {
                        throw new ValidationException(format("GAX references missing resource: %s", referencedFilename));
                    }
                    return contentsByFilename.get(referencedFilename);
                })
                .collect(Collectors.toList());
    }

    private List<Path> findGaxTranslatedResources(final Collection<String> resourceNames, final Map<String, Path> contentsByFilename) {
        final Set<String> referencedFilenameBases = resourceNames.stream()
                .map(FilenameUtils::removeExtension)
                .collect(Collectors.toSet());

        return contentsByFilename.entrySet().stream()
                .filter(entry -> {
                    final String uploadedFilename = removeExtension(entry.getKey());
                    final Matcher matcher = TRANSLATED_RESOURCE_FILENAME.matcher(uploadedFilename);
                    if (!matcher.matches()) {
                        return false;
                    }

                    final String referencedFilename = matcher.group(1);
                    return referencedFilenameBases.contains(referencedFilename);
                })
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
    }
}
