/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.service;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.opentestsystem.ap.common.model.ItemBankUser;
import org.opentestsystem.ap.common.model.ItemDiff;
import org.opentestsystem.ap.common.model.ItemHistory;
import org.opentestsystem.ap.common.model.ItemResponse;
import org.opentestsystem.ap.common.model.WorkflowStatusEnum;
import org.opentestsystem.ap.common.repository.ItemRepository;
import org.opentestsystem.ap.common.util.SecurityUtil;
import org.opentestsystem.ap.common.util.SystemException;
import org.opentestsystem.ap.ims.entity.WorkflowStatus;
import org.opentestsystem.ap.ims.repository.WorkflowStatusRepository;
import org.opentestsystem.ap.ims.rest.ItemChangeRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * The item management service.
 */
@Slf4j
@Component
public class ItemService {

    private static final boolean KEEP_CHANGES_PRIVATE = false;

    private static final boolean MAKE_CHANGES_PUBLIC = true;

    private final ItemRepository itemRepository;

    private final WorkflowStatusRepository workflowStatusRepository;

    private final ItemServiceValidator validator;

    private final SecurityUtil securityUtil;

    @Autowired
    public ItemService(final ItemRepository itemRepository,
                       final WorkflowStatusRepository workflowStatusRepository,
                       final ItemServiceValidator validator,
                       final SecurityUtil securityUtil) {
        this.itemRepository = itemRepository;
        this.workflowStatusRepository = workflowStatusRepository;
        this.validator = validator;
        this.securityUtil = securityUtil;
    }

    // ------------------------------------------------------------------------

    public List<WorkflowStatus> findAllWorkflowStatus() {
        return workflowStatusRepository.findAllByOrderByWorkflowOrderAsc();
    }

    public WorkflowStatus findWorkflowStatus(final String code) {
        return workflowStatusRepository.findFirstByCode(code);
    }

    // ------------------------------------------------------------------------

    /**
     * Find an item by its unique ID.
     *
     * @param itemId A unique item identifier.
     * @return An item.
     */
    public ItemResponse findItem(final String itemId) {
        log.debug("find item {}", itemId);
        validator.validateFindItem(itemId);
        final ItemBankUser user = securityUtil.getItemBankUser();
        return itemRepository.findItem(user, itemId);
    }

    /**
     * Finds the history of an item.
     *
     * @param itemId The unique item identifier.
     * @return A list of changes associated with the item.
     */
    public List<ItemHistory> findItemHistory(final String itemId) {
        log.debug("find item history for {}", itemId);
        validator.validateFindItemHistory(itemId);
        return itemRepository.findItemHistory(itemId);
    }

    /**
     * Finds the history and puts it in CSV format
     *
     * @param itemId The unique item identifier.
     * @return The item history in CSV format.
     */
    public String findItemHistoryCsvString(final String itemId) {
        log.debug("find item history csv string for {}", itemId);
        validator.validateFindItemHistory(itemId);
        return itemRepository.findItemHistoryCsvString(itemId);
    }

    /**
     * Returns a list of difference comparing the history ID with its previous history item.
     *
     * @param itemId    The unique item identifier.
     * @param historyId The history identifier to compare.
     * @return A list of difference from the previous history item to the given history item.
     */
    public List<ItemDiff.Diff> findItemDiff(final String itemId, final String historyId) {
        log.debug("find item diff for item {} and history id {}", itemId, historyId);
        validator.validateFindItemDiff(itemId, historyId);
        return itemRepository.findItemDiff(itemId, historyId);
    }

    // ------------------------------------------------------------------------

    /**
     * Creates an item in the item bank.  The create can be canceled.  When canceled the item is deleted from the item
     * bank.
     *
     * @param itemType      The type of item to create.
     * @param commitMessage The commit message starting an item create the transaction.
     * @return The new item.
     */
    public ItemResponse beginCreateTransaction(final String itemType,
                                               final String commitMessage) {
        log.debug("begin create transaction for item type {}", itemType);
        validator.validateBeginCreateTransaction(itemType, commitMessage);
        final ItemBankUser user = securityUtil.getItemBankUser();
        return itemRepository.createItem(user, itemType, commitMessage, WorkflowStatusEnum.Draft.name());
    }

    /**
     * Starts an edit transaction on an item.  The section is locked for editing by the requesting user. Section
     * edits can be rolled back. When rolling back the changes are undone.
     *
     * @param itemId        The unique item identifier.
     * @param section       The section to begin editing.
     * @param commitMessage The message associated with opening the item for editing.
     * @return The item to be edited.
     */
    public ItemResponse beginEditTransaction(final String itemId, final String section, final String commitMessage) {
        log.debug("begin edit transaction for item {} section {}", itemId, section);
        validator.validateBeginEditTransaction(itemId, section, commitMessage);
        final ItemBankUser user = securityUtil.getItemBankUser();
        return itemRepository.beginItemEdit(user, itemId, section, commitMessage);
    }

    /**
     * Save changes to the item.  The changes are saved on the creator/editor's scratch pad.
     *
     * @param itemId  The unique item identifier.
     * @param request The item data to save.
     */
    public void saveTransaction(final String itemId, final ItemChangeRequest request) {
        log.debug("save item {}", itemId);
        validator.validateSaveTransaction(itemId, request);
        request.getItem().setId(itemId);
        itemRepository.saveItem(securityUtil.getItemBankUser(), request.getItem(),
            request.getMessage(), KEEP_CHANGES_PRIVATE);
    }

    /**
     * Make public the changes associated the transaction.
     *
     * @param itemId  The unique item identifier.
     * @param request The item data to save and commit.
     */
    public void commitTransaction(final String itemId, final ItemChangeRequest request) {
        log.debug("commit item {}", itemId);
        validator.validateCommitTransaction(itemId, request);
        request.getItem().setId(itemId);
        itemRepository.saveItem(securityUtil.getItemBankUser(), request.getItem(),
            request.getMessage(), MAKE_CHANGES_PUBLIC);
    }

    /**
     * Rollback the transaction.
     *
     * @param itemId The unique item identifier.
     */
    public void rollbackTransaction(final String itemId) {
        log.debug("rollback item edits for item {}", itemId);
        validator.validateRollbackTransaction(itemId);
        final ItemBankUser user = securityUtil.getItemBankUser();
        itemRepository.rollbackEdits(user, itemId);
    }

    /**
     * Clones the item locally and returns the path to the file in that repository.
     *
     * @param itemId   The item to clone.
     * @param fileName The file to find the path to.
     * @return The path to the file on the local file system.
     */
    public Path getBrailleFilePath(final String itemId, final String fileName) {
        validator.validateGetBrailleFilePath(itemId, fileName);
        log.debug("get braille file path for file {}", fileName);
        final ItemBankUser user = securityUtil.getItemBankUser();
        final Path path = itemRepository.cloneItem(user, itemId);
        return Paths.get(path.toString(), fileName);
    }

    /**
     * Deletes the given folder from the local file system.
     *
     * @param folderToDelete The folder to delete.
     */
    public void deleteLocalRepo(final Path folderToDelete) {
        try {
            FileUtils.deleteDirectory(folderToDelete.toFile());
        } catch (IOException e) {
            throw new SystemException("Error deleting folder " + folderToDelete.toString());
        }
    }

}
