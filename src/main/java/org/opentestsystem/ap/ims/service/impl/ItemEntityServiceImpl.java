package org.opentestsystem.ap.ims.service.impl;

import com.amazonaws.services.s3.model.S3Object;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.tika.Tika;
import org.apache.tika.detect.NameDetector;
import org.apache.tika.io.TikaInputStream;
import org.apache.tika.metadata.Metadata;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.rest.item.ItemCommitResponse;
import org.opentestsystem.ap.common.rest.item.ItemEntityResponse;
import org.opentestsystem.ap.ims.ContentTypeMappings;
import org.opentestsystem.ap.ims.model.ItemResource;
import org.opentestsystem.ap.ims.service.ItemEntityService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.InputStreamResource;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;

@Slf4j
@Service
public class ItemEntityServiceImpl implements ItemEntityService {

    private final ItemBankProperties itemBankProperties;

    private final ContentTypeMappings contentTypeMappings;

    private final DataStoreDataManager dataStoreDataManager;

    private final DataStoreAttachmentManager dataStoreAttachmentManager;

    private Map<Pattern, org.apache.tika.mime.MediaType> customMediaTypes;

    @Autowired
    public ItemEntityServiceImpl(ItemBankProperties itemBankProperties,
                                 ContentTypeMappings contentTypeMappings,
                                 DataStoreDataManager dataStoreDataManager,
                                 DataStoreAttachmentManager dataStoreAttachmentManager) {
        this.itemBankProperties = itemBankProperties;
        this.contentTypeMappings = contentTypeMappings;
        this.dataStoreDataManager = dataStoreDataManager;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
    }

    @PostConstruct
    public void initialize() {
        Path path = Paths.get(this.itemBankProperties.getLocalBaseDir());
        if (!Files.exists(path)) {
            log.info(format("Creating folder %s", path));
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                log.error(format("Error creating folder %s.  Message: %s", path, e.getMessage()), e);
            }
        }

        this.customMediaTypes = new HashMap<>();

        this.customMediaTypes = this.contentTypeMappings.getMappings().entrySet().stream()
            .collect(
                Collectors.toMap(e ->
                    Pattern.compile(".*[.]" + e.getKey()), e -> org.apache.tika.mime.MediaType.parse(e.getValue())
                )
            );
    }

    @Override
    public Optional<ItemEntityResponse> findItemEntityById(UUID id) {
        ItemEntity entity = dataStoreDataManager.findItemEntityById(id);
        return Objects.isNull(entity) ? Optional.empty() : Optional.of(ItemEntityResponse.fromEntity(entity));
    }

    @Override
    public ItemCommitResponse findMasterItemCommitsSinceCommit(String itemId, UUID fromCommitId) {
        List<UUID> commitsSinceFromCommit = dataStoreDataManager.findCommitsSinceCommit(itemId, fromCommitId);
        return new ItemCommitResponse(itemId, commitsSinceFromCommit);
    }

    @Override
    public Optional<ItemEntityResponse> findLatestItemEntity(final String itemId) {
        ItemEntity entity = dataStoreDataManager.findLastMaster(itemId);
        return Objects.isNull(entity) ? Optional.empty() : Optional.of(ItemEntityResponse.fromEntity(entity));
    }

    @Override
    public ItemCommitResponse findAllItemCommits(final String itemId) {
        List<UUID> commits = dataStoreDataManager.findCommitsForItem(itemId);
        return new ItemCommitResponse(itemId, commits);
    }

    @Override
    public Optional<ItemResource> findItemResource(String itemId, String fileName) {
        return this.findItemResource(itemId, BRANCH_MASTER, fileName);
    }

    @Override
    public Optional<ItemResource> findItemResource(String itemId, UUID version, String fileName) {
        // TODO Fix this so it gets the correct version of the item resource.
        ItemEntity entity = dataStoreDataManager.findItemEntityById(version);
        return Objects.isNull(entity)
            ? Optional.empty()
            : this.findItemResource(itemId, entity.getBranchName(), fileName);
    }

    /**
     * This method simply gets the latest version of the item's resource.  The long term functionality will consider a
     * version ID value that will get that specific version for the given file.
     */
    private Optional<ItemResource> findItemResource(String itemId, String branchName, String fileName) {
        Optional<S3Object> optionalS3Object = this.dataStoreAttachmentManager.getS3Object(itemId, branchName, fileName);
        return Optional.ofNullable(optionalS3Object.map(s3 -> this.buildItemResource(s3, fileName)).orElse(null));
    }

    /**
     * This methods writes the S3 file to disk so that it can determine what content-type the file is.
     *
     * @param s3Object The S3 file information.
     * @param fileName The name of the file
     * @return The item resource.
     */
    private ItemResource buildItemResource(S3Object s3Object, String fileName) {
        File tempFile = null;
        ItemResource itemResource = null;
        try {
            Path tempFilePath = this.writeFileToDisk(s3Object, fileName);
            tempFile = tempFilePath.toFile();

            String mediaType = this.determineMediaType(tempFilePath, fileName);

            itemResource = ItemResource.builder()
                .mediaType(MediaType.valueOf(mediaType))
                .inputStreamResource(new InputStreamResource(new FileInputStream(tempFile)))
                .build();

        } catch (IOException e) {
            log.error(format("Unexpected error getting resource %s. Message: %s", fileName, e.getMessage()), e);
        } finally {
            FileUtils.deleteQuietly(tempFile);
        }
        return itemResource;
    }

    private Path writeFileToDisk(S3Object s3Object, String fileName) throws IOException {
        // account for glossary files being in a folder
        if (StringUtils.startsWith(fileName, "glossary/")) {
            fileName = fileName.replace("glossary/", StringUtils.EMPTY);
        }
        String prefix = FilenameUtils.getBaseName(fileName);
        String suffix = "." + FilenameUtils.getExtension(fileName);

        Path tempFilePath = Files.createTempFile(
            Paths.get(this.itemBankProperties.getLocalBaseDir()), prefix, suffix);

        FileUtils.copyInputStreamToFile(s3Object.getObjectContent(), tempFilePath.toFile());

        return tempFilePath;
    }

    private String determineMediaType(Path filePath, String fileName) throws IOException {
        Metadata metadata = new Metadata();
        metadata.set(Metadata.RESOURCE_NAME_KEY, fileName);

        // first look for our custom ones
        String mediaType = this.determineMediaType(
            new Tika(new NameDetector(this.customMediaTypes)),
            filePath,
            metadata);

        // application/octet-stream is the default and likely indicates the type
        // could not be determined, given that try to determine the media type
        // the default way
        if (MediaType.APPLICATION_OCTET_STREAM_VALUE.equals(mediaType)) {
            mediaType = this.determineMediaType(new Tika(), filePath, metadata);
        }

        return mediaType;
    }

    private String determineMediaType(Tika tika, Path filePath, Metadata metadata) throws IOException {
        try (TikaInputStream is = TikaInputStream.get(filePath)) {
            return tika.detect(is, metadata);
        }
    }
}