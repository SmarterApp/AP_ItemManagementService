package org.opentestsystem.ap.ims.service.impl;

import com.amazonaws.services.s3.model.S3Object;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.tika.detect.DefaultDetector;
import org.apache.tika.detect.Detector;
import org.apache.tika.metadata.Metadata;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.rest.item.ItemCommitResponse;
import org.opentestsystem.ap.common.rest.item.ItemEntityResponse;
import org.opentestsystem.ap.ims.model.ItemResource;
import org.opentestsystem.ap.ims.service.ItemEntityService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.InputStreamResource;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;

import static java.lang.String.format;
import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;

@Slf4j
@Service
public class ItemEntityServiceImpl implements ItemEntityService {

    private final ItemBankProperties itemBankProperties;

    private final DataStoreDataManager dataStoreDataManager;

    private final DataStoreAttachmentManager dataStoreAttachmentManager;

    private final Detector detector;

    private final Metadata metadata;

    @Autowired
    public ItemEntityServiceImpl(ItemBankProperties itemBankProperties,
                                 DataStoreDataManager dataStoreDataManager,
                                 DataStoreAttachmentManager dataStoreAttachmentManager) {
        this.itemBankProperties = itemBankProperties;
        this.dataStoreDataManager = dataStoreDataManager;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
        this.detector = new DefaultDetector();
        this.metadata = new Metadata();
    }

    @PostConstruct
    public void initialize() {
        Path path = Paths.get(this.itemBankProperties.getLocalBaseDir());
        if (!Files.exists(path)) {
            log.info(format("Creating folder %s", path));
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                log.error(format("Error creating folder %s.  Message: %s", path, e.getMessage()), e);
            }
        }
    }

    @Override
    public Optional<ItemEntityResponse> findItemEntityById(UUID id) {
        ItemEntity entity = dataStoreDataManager.findItemEntityById(id);
        return Objects.isNull(entity) ? Optional.empty() : Optional.of(ItemEntityResponse.fromEntity(entity));
    }

    @Override
    public ItemCommitResponse findMasterItemCommitsSinceCommit(String itemId, UUID fromCommitId) {
        List<UUID> commitsSinceFromCommit = dataStoreDataManager.findCommitsSinceCommit(itemId, fromCommitId);
        return new ItemCommitResponse(itemId, commitsSinceFromCommit);
    }

    @Override
    public Optional<ItemEntityResponse> findLatestItemEntity(final String itemId) {
        ItemEntity entity = dataStoreDataManager.findLastMaster(itemId);
        return Objects.isNull(entity) ? Optional.empty() : Optional.of(ItemEntityResponse.fromEntity(entity));
    }

    @Override
    public ItemCommitResponse findAllItemCommits(final String itemId) {
        List<UUID> commits = dataStoreDataManager.findCommitsForItem(itemId);
        return new ItemCommitResponse(itemId, commits);
    }

    @Override
    public Optional<ItemResource> findItemResource(String itemId, String fileName) {
        return this.findItemResource(itemId, BRANCH_MASTER, fileName);
    }

    @Override
    public Optional<ItemResource> findItemResource(String itemId, UUID version, String fileName) {
        // TODO Fix this so it gets the correct version of the item resource.
        ItemEntity entity = dataStoreDataManager.findItemEntityById(version);
        return Objects.isNull(entity)
            ? Optional.empty()
            : this.findItemResource(itemId, entity.getBranchName(), fileName);
    }

    /**
     * This method simply gets the latest version of the item's resource.  The long term functionality will consider a
     * version ID value that will get that specific version for the given file.
     */
    private Optional<ItemResource> findItemResource(String itemId, String branchName, String fileName) {
        Optional<S3Object> optionalS3Object = this.dataStoreAttachmentManager.getS3Object(itemId, branchName, fileName);
        return Optional.ofNullable(optionalS3Object.map(s3 -> this.buildItemResource(s3, fileName)).orElse(null));
    }

    /**
     * This methods writes the S3 file to disk so that it can determine what content-type the file is.
     *
     * @param s3Object The S3 file information.
     * @param fileName The name of the file
     * @return The item resource.
     */
    private ItemResource buildItemResource(S3Object s3Object, String fileName) {
        File tempFile = null;
        ItemResource itemResource = null;
        try {
            // account for glossary files being in a folder
            if (StringUtils.startsWith(fileName, "glossary/")) {
                fileName = fileName.replace("glossary/", StringUtils.EMPTY);
            }
            String prefix = FilenameUtils.getBaseName(fileName);
            String suffix = "." + FilenameUtils.getExtension(fileName);

            Path tempFilePath = Files.createTempFile(
                Paths.get(this.itemBankProperties.getLocalBaseDir()), prefix, suffix);

            tempFile = tempFilePath.toFile();

            FileUtils.copyInputStreamToFile(s3Object.getObjectContent(), tempFile);

            org.apache.tika.mime.MediaType mediaType = detector.detect(
                new BufferedInputStream(new FileInputStream(tempFile)), metadata);

            itemResource = ItemResource.builder()
                .mediaType(MediaType.valueOf(mediaType.toString()))
                .inputStreamResource(new InputStreamResource(new FileInputStream(tempFile)))
                .build();

        } catch (IOException e) {
            log.error(format("Unexpected error getting resource %s. Message: %s", fileName, e.getMessage()), e);
        } finally {
            FileUtils.deleteQuietly(tempFile);
        }
        return itemResource;
    }
}
