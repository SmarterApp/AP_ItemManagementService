package org.opentestsystem.ap.ims.service.export;

import com.itextpdf.html2pdf.ConverterProperties;
import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.layout.Document;
import lombok.extern.slf4j.Slf4j;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.exception.ValidationException;
import org.opentestsystem.ap.common.model.ItemContext;
import org.opentestsystem.ap.common.model.ItemResponse;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.util.SecurityUtil;
import org.opentestsystem.ap.ims.model.export.ItemExport;
import org.opentestsystem.ap.ims.service.ItemService;
import org.opentestsystem.ap.ims.service.export.writer.ItemContentWriter;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Instant;
import java.util.Collection;
import java.util.Optional;
import java.util.UUID;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static com.itextpdf.kernel.events.PdfDocumentEvent.INSERT_PAGE;
import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_TUT;

@Slf4j
@Service
public class PdfItemExportServiceImpl implements ItemExportService {
    private final ItemService itemService;
    private final Collection<ItemContentWriter> itemContentWriters;
    private final AppAssembler appAssembler;
    private final ItemExportRepository itemExportRepository;
    private final SecurityUtil securityUtil;

    public PdfItemExportServiceImpl(final ItemService itemService,
                                    final Collection<ItemContentWriter> itemContentWriters,
                                    final AppAssembler appAssembler,
                                    final ItemExportRepository itemExportRepository,
                                    final SecurityUtil securityUtil) {
        this.itemService = itemService;
        this.itemContentWriters = itemContentWriters;
        this.appAssembler = appAssembler;
        this.itemExportRepository = itemExportRepository;
        this.securityUtil = securityUtil;
    }

    @Override
    public Optional<File> exportItem(final String itemId, final boolean includeRubrics) {
        final ItemResponse itemResponse = itemService.findItem(itemId);

        if (itemResponse.getItem() == null) {
            return Optional.empty();
        } else if (itemResponse.getItem().getType().equals(TYPE_TUT)) {
            throw new ValidationException(TYPE_TUT + " type is not supported");
        }

        try {
            Path path = Files.createTempDirectory(UUID.randomUUID().toString());
            Path clonedItemPath = itemExportRepository.cloneItemForExport(path, itemId);

            ItemRelease itemRelease = getItemRelease(itemId, clonedItemPath);

            File itemFiles = new File(path.toFile(), "itemFiles");
            itemFiles.mkdir();
            File zipFile = new File(path.toFile(), itemId + ".zip");

            ItemContext itemContext = new ItemContext(itemId, appAssembler, clonedItemPath);

            ItemExport itemExport = new ItemExport(Instant.now(), securityUtil.getUsername(), itemResponse.getItem(), itemRelease, clonedItemPath, includeRubrics, itemContext);

            File pdfFile = createPdf(itemExport);
            Files.move(pdfFile.toPath(), new File(itemFiles, pdfFile.getName()).toPath());

            pack(Paths.get(itemFiles.toURI()), Paths.get(zipFile.toURI()));

            log.info("Output for files " + path.toAbsolutePath());

            return Optional.of(zipFile);
        } catch (IOException ioe) {
            throw new RuntimeException("Unhandled Exception when exporting item", ioe);
        }
    }

    private ItemRelease getItemRelease(final String itemId, final Path itemDirectory) {
        File[] files = itemDirectory.toFile().listFiles((dir, name) -> name.equals(itemId + ".xml"));

        if (files == null || files.length != 1) {
            throw new IllegalStateException("A single item xml should be present for item " + itemId);
        }

        return appAssembler.getSaaifAssembler().readXmlFromFile(files[0].toPath());
    }

    private File createPdf(ItemExport itemExport) throws IOException {
        final String itemId = itemExport.getItem().getId();
        final String pdfName = itemId + ".pdf";
        File pdfFile = new File(itemExport.getClonedItemDirectory().toFile(), pdfName);

        pdfFile.createNewFile();

        try (FileOutputStream fos = new FileOutputStream(pdfFile)) {
            PdfWriter writer = new PdfWriter(fos);
            PdfDocument pdf = new PdfDocument(writer);

            Document document = new Document(pdf);
            PdfWriter pdfWriter = new PdfWriter(fos);
            pdf.addEventHandler(INSERT_PAGE, new ItemHeaderListener(itemId, document));

            ConverterProperties properties = new ConverterProperties();
            properties.setBaseUri(itemExport.getClonedItemDirectory().toUri().toString());

            for (ItemContentWriter contentWriter : itemContentWriters) {
                if (contentWriter.supportsItemType(itemExport.getItem())) {
                    contentWriter.addContent(pdfWriter, document, properties, itemExport);
                    break;
                }
            }

            document.close();

            return pdfFile;
        } catch (IOException e) {
            throw new RuntimeException("Unexpected issue creating the pdf", e);
        }
    }

    private static void pack(final Path folder, final Path zipFilePath) throws IOException {
        try (
                FileOutputStream fos = new FileOutputStream(zipFilePath.toFile());
                ZipOutputStream zos = new ZipOutputStream(fos)
        ) {
            Files.walkFileTree(folder, new SimpleFileVisitor<Path>() {
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    zos.putNextEntry(new ZipEntry(folder.relativize(file).toString()));
                    Files.copy(file, zos);
                    zos.closeEntry();
                    return FileVisitResult.CONTINUE;
                }

                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                    zos.putNextEntry(new ZipEntry(folder.relativize(dir).toString() + "/"));
                    zos.closeEntry();
                    return FileVisitResult.CONTINUE;
                }
            });
        }
    }
}
