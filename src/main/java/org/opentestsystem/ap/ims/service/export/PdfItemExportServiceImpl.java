package org.opentestsystem.ap.ims.service.export;

import com.itextpdf.html2pdf.ConverterProperties;
import com.itextpdf.html2pdf.HtmlConverter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.datastore.DataStorePreviewManager;
import org.opentestsystem.ap.common.exception.ValidationException;
import org.opentestsystem.ap.common.model.ItemContext;
import org.opentestsystem.ap.common.model.ItemResponse;
import org.opentestsystem.ap.common.model.PreviewData;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.util.SecurityUtil;
import org.opentestsystem.ap.ims.model.export.ItemExport;
import org.opentestsystem.ap.ims.service.ItemService;
import org.opentestsystem.ap.ims.service.export.io.ItemFileExporter;
import org.opentestsystem.ap.ims.service.export.writer.ItemContentWriter;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Instant;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_TUT;

@Slf4j
@Service
public class PdfItemExportServiceImpl implements ItemExportService {
    private final ItemService itemService;
    private final Collection<ItemContentWriter> itemContentWriters;
    private final AppAssembler appAssembler;
    private final SecurityUtil securityUtil;
    private final List<ItemFileExporter> itemFileExporters;
    private final DataStorePreviewManager previewManager;

    //This input images are necessary because iText can't display form options.
    private List<String> images = Arrays.asList(
            "audio-icon.png",
            "option0.png",
            "option1.png",
            "option2.png",
            "option3.png",
            "option4.png",
            "option5.png",
            "option6.png",
            "option7.png",
            "option8.png",
            "option9.png",
            "option.png",
            "checkbox.png"
    );

    public PdfItemExportServiceImpl(final ItemService itemService,
                                    final Collection<ItemContentWriter> itemContentWriters,
                                    final AppAssembler appAssembler,
                                    final SecurityUtil securityUtil,
                                    final List<ItemFileExporter> itemFileExporters,
                                    final DataStorePreviewManager previewManager) {
        this.itemService = itemService;
        this.itemContentWriters = itemContentWriters;
        this.appAssembler = appAssembler;
        this.securityUtil = securityUtil;
        this.itemFileExporters = itemFileExporters;
        this.previewManager = previewManager;
    }

    @Override
    public Optional<File> exportItem(final String itemId, final boolean includeRubrics) {
        final ItemResponse itemResponse = itemService.findItem(itemId);

        if (itemResponse.getItem() == null) {
            return Optional.empty();
        } else if (itemResponse.getItem().getType().equals(TYPE_TUT)) {
            throw new ValidationException(TYPE_TUT + " type is not supported");
        }

        try {
            Path path = Files.createTempDirectory(UUID.randomUUID().toString());
            PreviewData previewData = previewManager.generatePreviewData(securityUtil.getItemBankUser(), itemId, Collections.emptyList());
            Path clonedItemPath = previewData.getRepositoryPath();

            ItemRelease itemRelease = getItemRelease(itemId, clonedItemPath);

            File itemFiles = new File(path.toFile(), "itemFiles");
            itemFiles.mkdir();
            File zipFile = new File(path.toFile(), itemId + ".zip");

            ItemContext itemContext = new ItemContext(itemId, appAssembler, clonedItemPath);

            ItemExport itemExport = new ItemExport(Instant.now(), securityUtil.getUsername(), itemResponse.getItem(), itemRelease, clonedItemPath, includeRubrics, itemContext);

            moveImages(clonedItemPath);
            File pdfFile = createPdf(itemExport);
            Files.move(pdfFile.toPath(), new File(itemFiles, pdfFile.getName()).toPath());
            moveAssociatedItemFiles(itemFiles.toPath(), itemExport);

            //TODO - Remove before commit
//            move(clonedItemPath.toFile(), itemFiles);

            pack(Paths.get(itemFiles.toURI()), Paths.get(zipFile.toURI()));

            return Optional.of(zipFile);
        } catch (IOException ioe) {
            throw new RuntimeException("Unhandled Exception when exporting item", ioe);
        }
    }

    private ItemRelease getItemRelease(final String itemId, final Path itemDirectory) {
        File[] files = itemDirectory.toFile().listFiles((dir, name) -> name.equals(itemId + ".xml"));

        if (files == null || files.length != 1) {
            throw new IllegalStateException("A single item xml should be present for item " + itemId);
        }

        return appAssembler.getSaaifAssembler().readXmlFromFile(files[0].toPath());
    }

    private File createPdf(ItemExport itemExport) throws IOException {
        final String itemId = itemExport.getItem().getId();
        final String pdfName = itemId + ".pdf";
        File pdfFile = new File(itemExport.getClonedItemDirectory().toFile(), pdfName);

        pdfFile.createNewFile();

        try (FileOutputStream fos = new FileOutputStream(pdfFile)) {
            ConverterProperties properties = new ConverterProperties();
            properties.setBaseUri(itemExport.getClonedItemDirectory().toUri().toString());

            String html = StringUtils.EMPTY;
            for (ItemContentWriter contentWriter : itemContentWriters) {
                if (contentWriter.supportsItemType(itemExport.getItem())) {
                    html = contentWriter.getHtml(itemExport);
                    break;
                }
            }

            HtmlConverter.convertToPdf(html, fos, properties);

            return pdfFile;
        } catch (IOException e) {
            throw new RuntimeException("Unexpected issue creating the pdf", e);
        }
    }

    private void moveAssociatedItemFiles(Path itemFilesLocationForZip, ItemExport itemExport) {
        for (ItemFileExporter exporter : itemFileExporters) {
            if (exporter.handlesItem(itemExport)) {
                List<Path> exportedFiles = exporter.findAssociatedFilesForExport(itemExport);
                for (Path path : exportedFiles) {
                    File newLocation = new File(itemFilesLocationForZip.toFile(), path.toFile().getName());

                    try (FileInputStream fis = new FileInputStream(path.toFile());
                         FileOutputStream fos = new FileOutputStream(newLocation)) {
                        IOUtils.copy(fis, fos);
                    } catch (IOException ioe) {
                        throw new RuntimeException("Failed to move files");
                    }
                }
            }
        }
    }

    private static void pack(final Path folder, final Path zipFilePath) throws IOException {
        try (
                FileOutputStream fos = new FileOutputStream(zipFilePath.toFile());
                ZipOutputStream zos = new ZipOutputStream(fos)
        ) {
            Files.walkFileTree(folder, new SimpleFileVisitor<Path>() {
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    zos.putNextEntry(new ZipEntry(folder.relativize(file).toString()));
                    Files.copy(file, zos);
                    zos.closeEntry();
                    return FileVisitResult.CONTINUE;
                }

                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                    zos.putNextEntry(new ZipEntry(folder.relativize(dir).toString() + "/"));
                    zos.closeEntry();
                    return FileVisitResult.CONTINUE;
                }
            });
        }
    }
//
//    //TODO - Remove before going to production
//    private boolean move(File sourceFile, File destFile) {
//        if (sourceFile.isDirectory()) {
//            for (File file : sourceFile.listFiles()) {
//                move(file, new File(destFile, file.getName()));
//            }
//        } else {
//            try {
//                Files.move(Paths.get(sourceFile.getPath()), Paths.get(destFile.getPath()), StandardCopyOption.REPLACE_EXISTING);
//                return true;
//            } catch (IOException e) {
//                return false;
//            }
//        }
//        return false;
//    }

    private void moveImages(Path clonedItemDirectory) {
        for(String icon : images) {
            ClassPathResource audioIcon = new ClassPathResource("static/images/" + icon);

            File newLocation = new File(clonedItemDirectory.toFile(), icon);

            try (InputStream fis = audioIcon.getInputStream();
                 FileOutputStream fos = new FileOutputStream(newLocation)) {
                org.python.apache.commons.compress.utils.IOUtils.copy(fis, fos);
            } catch (IOException ioe) {
                throw new RuntimeException("Could not move audio image file");
            }
        }
    }
}
