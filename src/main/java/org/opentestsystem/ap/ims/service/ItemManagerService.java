/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.service;

import lombok.extern.slf4j.Slf4j;
import org.opentestsystem.ap.common.itembank.IdGenerator;
import org.opentestsystem.ap.common.management.ItemManager;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemConstants;
import org.opentestsystem.ap.common.model.ItemDiff;
import org.opentestsystem.ap.common.model.ItemHistory;
import org.opentestsystem.ap.common.model.ItemMetadata;
import org.opentestsystem.ap.common.model.ItemPatchRequest;
import org.opentestsystem.ap.common.model.ItemResponse;
import org.opentestsystem.ap.common.model.ServerManaged;
import org.opentestsystem.ap.common.model.WorkflowStatus;
import org.opentestsystem.ap.common.model.WorkflowStatusTransition;
import org.opentestsystem.ap.common.model.eqconfig.EqEquationEditorConfiguration;
import org.opentestsystem.ap.common.util.ContentSpecIdUtil;
import org.opentestsystem.ap.common.util.SecurityUtil;
import org.opentestsystem.ap.ims.rest.ItemChangeRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

import static com.itextpdf.styledxmlparser.css.CommonCssConstants.EMPTY;

/**
 * The item management service.
 */
@Slf4j
@Service
public class ItemManagerService {

    private final ItemManager itemManager;

    private final ItemManagerValidator validator;

    private final SecurityUtil securityUtil;

    private final IdGenerator idGenerator;

    private final ContentSpecIdUtil contentSpecIdUtil;

    @Autowired
    public ItemManagerService(ItemManager itemManager,
                              ItemManagerValidator validator,
                              SecurityUtil securityUtil,
                              IdGenerator idGenerator,
                              ContentSpecIdUtil contentSpecIdUtil) {
        this.itemManager = itemManager;
        this.validator = validator;
        this.securityUtil = securityUtil;
        this.idGenerator = idGenerator;
        this.contentSpecIdUtil = contentSpecIdUtil;
    }

    // ------------------------------------------------------------------------

    /**
     *
     * @return
     */
    @Transactional(readOnly = true)
    public List<WorkflowStatus> findAllWorkflowStatus() {
        itemManager.findAllWorkflowStatuses();
        return itemManager.findAllWorkflowStatuses();
    }

    /**
     *
     * @param currentStatusCode
     * @return
     */
    @Transactional(readOnly = true)
    public List<WorkflowStatusTransition> findAllowedWorkflowStatuses(String currentStatusCode) {
        return itemManager.findAllowedWorkflowStatuses(currentStatusCode);
    }

    /**
     *
     * @return
     */
    public List<EqEquationEditorConfiguration> findAllEquationEditorConfigurations() {
        return itemManager.findAllEqEquationEditorConfigurations();
    }

    // ------------------------------------------------------------------------

    /**
     * Find an item by its unique ID.
     *
     * @param itemId A unique item identifier.
     * @return An item.
     */
    @Transactional
    public ItemResponse findItem(String itemId) {
        log.debug("find item {}", itemId);
        validator.validateFindItem(itemId);
        return itemManager.findItem(securityUtil.getItemBankUser(), itemId);
    }

    /**
     * Finds the history of an item.
     *
     * @param itemId The unique item identifier.
     * @return A list of changes associated with the item.
     */
    public List<ItemHistory> findItemHistory(String itemId) {
        log.debug("find item history for {}", itemId);
        validator.validateFindItemHistory(itemId);
        return itemManager.findItemHistory(itemId);
    }

    /**
     * Finds the history and puts it in CSV format
     *
     * @param itemId The unique item identifier.
     * @return The item history in CSV format.
     */
    public String findItemHistoryCsvString(String itemId) {
        log.debug("find item history csv string for {}", itemId);
        validator.validateFindItemHistory(itemId);
        return itemManager.findItemHistoryCsvString(itemId);
    }

    /**
     * Returns a list of difference comparing the history ID with its previous history item.
     *
     * @param itemId    The unique item identifier.
     * @param historyId The history identifier to compare.
     * @return A list of difference from the previous history item to the given history item.
     */
    public List<ItemDiff.Diff> findItemDiff(String itemId, String historyId) {
        log.debug("find item diff for item {} and history id {}", itemId, historyId);
        validator.validateFindItemDiff(itemId, historyId);
        return itemManager.findItemDiff(itemId, historyId);
    }

    // ------------------------------------------------------------------------

    /**
     * Creates an item in the item bank.  The create can be canceled.  When canceled the item is deleted from the item
     * bank.
     *
     * @param itemType      The type of item to create.
     * @param commitMessage The commit message starting an item create the transaction.
     * @return The new item.
     */
    @Transactional
    public ItemResponse beginCreateTransaction(String itemType, String commitMessage) {
        validator.validateBeginCreateTransaction(itemType, commitMessage);
        String itemId = idGenerator.generateItemId(itemType);
        log.info("begin create transaction for item type {} with id {}", itemType, itemId);
        return itemManager.createItem(securityUtil.getItemBankUser(), itemId, itemType, commitMessage);
    }

    /**
     * Starts an edit transaction on an item.  The section is locked for editing by the requesting user. Section edits
     * can be rolled back. When rolling back the changes are undone.
     *
     * @param itemId        The unique item identifier.
     * @param section       The section to begin editing.
     * @param commitMessage The message associated with opening the item for editing.
     * @return The item to be edited.
     */
    @Transactional
    public ItemResponse beginEditTransaction(String itemId, String section, String commitMessage) {
        log.debug("begin edit transaction for item {} section {}", itemId, section);
        validator.validateBeginEditTransaction(itemId, section, commitMessage);
        return itemManager.beginItemEdit(securityUtil.getItemBankUser(), itemId, section, commitMessage);
    }

    /**
     * Save changes to the item.  The changes are saved on the creator/editor's scratch pad.
     *
     * @param itemId  The unique item identifier.
     * @param request The item data to save.
     */
    @Transactional
    public void saveTransaction(String itemId, ItemChangeRequest request) {
        log.debug("save item {}", itemId);
        validator.validateSaveTransaction(itemId, request);
        Item item = request.getItem();
        updateServerManagedFields(item);
        this.itemManager.saveItem(securityUtil.getItemBankUser(), item, request.getMessage());
    }

    private void updateServerManagedFields(Item item) {
        if (item.getCore() == null || item.getCore().getMetadata() == null || item.getServerManaged() == null) {
            return;
        }

        String itemId = item.getId();

        ItemMetadata metadata = item.getCore().getMetadata();
        String subject = metadata.getSubject();
        String grade = metadata.getIntendedGrade();

        ServerManaged serverManaged = item.getServerManaged();
        serverManaged.setPrimaryEnhancedId(EMPTY);
        serverManaged.setSecondaryEnhancedId(EMPTY);
        serverManaged.setTertiaryEnhancedId(EMPTY);
        serverManaged.setQuaternaryEnhancedId(EMPTY);

        serverManaged.setPrimaryEnhancedId(contentSpecIdUtil.formatId(
                itemId,
                subject,
                grade,
                metadata.getPrimaryClaim(),
                metadata.getPrimaryTarget(),
                metadata.getPrimaryCommonCoreStandard(),
                metadata.getPrimaryContentDomain(),
                metadata.getPrimaryEmphasis()));

        if (isMath(subject)) {
            serverManaged.setSecondaryEnhancedId(contentSpecIdUtil.formatId(
                    itemId,
                    subject,
                    grade,
                    metadata.getSecondaryClaim(),
                    metadata.getSecondaryTarget(),
                    metadata.getSecondaryCommonCoreStandard(),
                    metadata.getSecondaryContentDomain()));

            serverManaged.setTertiaryEnhancedId(contentSpecIdUtil.formatId(
                    itemId,
                    subject,
                    grade,
                    metadata.getTertiaryClaim(),
                    metadata.getTertiaryTarget(),
                    metadata.getTertiaryCommonCoreStandard(),
                    metadata.getTertiaryContentDomain()));

            serverManaged.setQuaternaryEnhancedId(contentSpecIdUtil.formatId(
                    itemId,
                    subject,
                    grade,
                    metadata.getQuaternaryClaim(),
                    metadata.getQuaternaryTarget(),
                    metadata.getQuaternaryCommonCoreStandard(),
                    metadata.getQuaternaryContentDomain()));
        }
    }

    private boolean isMath(String subject) {
        if (subject == null) {
            return false;
        }

        return subject.trim().equalsIgnoreCase(ItemConstants.ItemSubject.SUBJECT_MATH);
    }

    /**
     * Make public the changes associated the transaction.
     *
     * @param itemId  The unique item identifier.
     * @param request The item data to save and commit.
     */
    @Transactional
    public void commitTransaction(String itemId, ItemChangeRequest request) {
        log.debug("commit item {}", itemId);
        validator.validateCommitTransaction(itemId, request);
        Item item = request.getItem();
        updateServerManagedFields(item);
        itemManager.commitItem(securityUtil.getItemBankUser(), item, request.getMessage());
    }

    /**
     * Make public the changes associated the transaction.
     *
     * @param itemId  The unique item identifier.
     * @param request The item data to save and commit.
     */
    @Transactional
    public void commitFieldChange(String itemId, String fieldPath, ItemChangeRequest request) {
        log.debug("commit item {}", itemId);
        validator.validateCommitFieldChange(itemId, fieldPath, request);
        ItemPatchRequest patchRequest = request.toPatchRequest();
        patchRequest.setItemId(itemId);
        patchRequest.setFieldPath(fieldPath);
        itemManager.patchItem(securityUtil.getItemBankUser(), patchRequest);
    }

    /**
     * Rollback the transaction.
     *
     * @param itemId The unique item identifier.
     */
    @Transactional
    public void rollbackTransaction(String itemId) {
        log.debug("rollback item edits for item {}", itemId);
        validator.validateRollbackTransaction(itemId);
        itemManager.rollbackEdits(securityUtil.getItemBankUser(), itemId);
    }
}
