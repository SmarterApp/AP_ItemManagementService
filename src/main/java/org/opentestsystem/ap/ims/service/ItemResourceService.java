package org.opentestsystem.ap.ims.service;

import com.amazonaws.services.s3.model.S3Object;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.tika.Tika;
import org.apache.tika.detect.NameDetector;
import org.apache.tika.io.TikaInputStream;
import org.apache.tika.metadata.Metadata;
import org.apache.tika.mime.MediaType;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.ims.ItemResourceProperties;
import org.opentestsystem.ap.ims.model.ItemResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.InputStreamResource;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;

/**
 * A service to determine the content type of different input sources.  A file on disk is the common case.
 */
@Slf4j
@Component
public class ItemResourceService {

    private final ItemResourceProperties itemResourceProperties;

    private final DataStoreDataManager dataStoreDataManager;

    private final DataStoreAttachmentManager dataStoreAttachmentManager;

    private final Tika tika;

    private final NameDetector nameDetector;

    private Map<Pattern, MediaType> customMediaTypes;

    public ItemResourceService(ItemResourceProperties itemResourceProperties,
                               DataStoreDataManager dataStoreDataManager,
                               DataStoreAttachmentManager dataStoreAttachmentManager) {
        this.itemResourceProperties = itemResourceProperties;
        this.customMediaTypes = this.constructCustomMediaTypes(itemResourceProperties);
        this.dataStoreDataManager = dataStoreDataManager;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
        this.tika = new Tika();
        this.nameDetector = new NameDetector(this.customMediaTypes);
    }

    private Map<Pattern, MediaType> constructCustomMediaTypes(ItemResourceProperties properties) {
        return properties.getMappings().entrySet().stream()
            .collect(
                Collectors.toMap(e ->
                    Pattern.compile(".*[.]" + e.getKey()), e -> org.apache.tika.mime.MediaType.parse(e.getValue())
                )
            );
    }

    @PostConstruct
    public void initialize() {
        Path path = Paths.get(this.itemResourceProperties.getResourceDir());
        if (!Files.exists(path)) {
            log.info(format("Creating folder %s", path));
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                log.error(format("Error creating folder %s.  Message: %s", path, e.getMessage()), e);
            }
        }

    }

    /**
     * Returns an item resource by item id and resource file name.  The resource being requested is associated with the
     * latest master version.  {@link org.opentestsystem.ap.common.exception.ValidationException} is thrown if any of
     * the arguments are null.
     *
     * @param itemId   an item identifier
     * @param fileName a resource file name
     * @return a found {@link ItemResource}
     */
    public Optional<ItemResource> findItemResource(String itemId, String fileName) {
        return this.findItemResource(itemId, BRANCH_MASTER, fileName);
    }

    /**
     * Returns an item resource by item id, version (required) and resource file name.  {@link
     * org.opentestsystem.ap.common.exception.ValidationException} is thrown if any of the arguments are null.
     *
     * @param itemId   an item identifier
     * @param version  an item version
     * @param fileName a resource file name
     * @return a found {@link ItemResource}
     */
    public Optional<ItemResource> findItemResource(String itemId, UUID version, String fileName) {
        // TODO Fix this so it gets the correct version of the item resource.
        ItemEntity entity = dataStoreDataManager.findItemById(version);
        return Objects.isNull(entity)
            ? Optional.empty()
            : this.findItemResource(itemId, entity.getBranchName(), fileName);
    }

    /**
     * This method simply gets the latest version of the item's resource.  The long term functionality will consider a
     * version ID value that will get that specific version for the given file.
     */
    private Optional<ItemResource> findItemResource(String itemId, String branchName, String fileName) {
        Optional<S3Object> optionalS3Object = this.dataStoreAttachmentManager.getS3Object(itemId, branchName, fileName);
        return Optional.ofNullable(optionalS3Object.map(s3 -> this.buildItemResource(s3, fileName)).orElse(null));
    }

    /**
     * This methods writes the S3 file to disk so that it can determine what content-type the file is.
     *
     * @param s3Object The S3 file information.
     * @param fileName The name of the file
     * @return The item resource.
     */
    private ItemResource buildItemResource(S3Object s3Object, String fileName) {
        File tempFile = null;
        ItemResource itemResource;
        try {
            String contentType = this.determineMediaType(fileName);

            if (this.isDefaultContentType(contentType)) {
                Path tempFilePath = this.writeFileToDisk(s3Object, fileName);
                tempFile = tempFilePath.toFile();

                String mediaType = this.determineMediaType(tempFilePath, fileName);

                itemResource = ItemResource.builder()
                    .mediaType(org.springframework.http.MediaType.valueOf(mediaType))
                    .inputStreamResource(new FileSystemResource(tempFilePath.toFile()))
                    .build();
            } else {
                itemResource = ItemResource.builder()
                    .mediaType(org.springframework.http.MediaType.valueOf(contentType))
                    .inputStreamResource(new InputStreamResource(s3Object.getObjectContent()))
                    .build();
            }
        } catch (IOException e) {
            log.error(format("Unexpected error getting resource %s. Message: %s", fileName, e.getMessage()), e);
            FileUtils.deleteQuietly(tempFile);
            throw new SystemException(format("Unexpected error getting resource %s.", fileName), e);
        }

        return itemResource;
    }

    private Path writeFileToDisk(S3Object s3Object, String fileName) throws IOException {
        // account for glossary files being in a folder
        if (StringUtils.startsWith(fileName, "glossary/")) {
            fileName = fileName.replace("glossary/", StringUtils.EMPTY);
        }
        String prefix = FilenameUtils.getBaseName(fileName);
        String suffix = "." + FilenameUtils.getExtension(fileName);

        Path tempFilePath = Files.createTempFile(
            Paths.get(this.itemResourceProperties.getResourceDir()), prefix, suffix);

        FileUtils.copyInputStreamToFile(s3Object.getObjectContent(), tempFilePath.toFile());

        return tempFilePath;
    }

    public String determineMediaType(String fileName) {
        Metadata metadata = new Metadata();
        metadata.set(Metadata.RESOURCE_NAME_KEY, fileName);
        return this.nameDetector.detect(null, metadata).toString();
    }

    /**
     * The file path and file name are used to determine the content type.  The content type is commonly used in an http
     * response.  The value returned is used to generate a {@link org.springframework.http.MediaType} instance.  If the
     * type cannot be determined the default value is "application/octet-stream".
     * <p>
     * There might be cases where a file maps to an invalid type.  The custom map can be used to override or define file
     * extensions to the content type you want.
     * </p>
     *
     * @param filePath A path to a file on disk.
     * @param fileName The name of the file.
     * @return
     * @throws IOException
     */
    public String determineMediaType(Path filePath, String fileName) throws IOException {
        Metadata metadata = new Metadata();
        metadata.set(Metadata.RESOURCE_NAME_KEY, fileName);
        return this.determineMediaType(filePath, metadata);
    }

    private String determineMediaType(Path filePath, Metadata metadata) throws IOException {
        // must close the input stream
        try (TikaInputStream is = TikaInputStream.get(filePath)) {
            return tika.detect(is, metadata);
        }
    }

    /**
     * Returns true if the value is the default content type.  The default is "application/octet-stream".
     *
     * @param contentType The value to compare against the default.
     * @return True if the value matches the default.
     */
    private boolean isDefaultContentType(String contentType) {
        return MediaType.OCTET_STREAM.toString().equals(contentType);
    }
}
