package org.opentestsystem.ap.ims.service.export.writer;

import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemConstants;
import org.opentestsystem.ap.common.model.MiItem;
import org.opentestsystem.ap.ims.model.export.AdditionalInfo;
import org.opentestsystem.ap.ims.model.export.Cell;
import org.opentestsystem.ap.ims.model.export.ItemExport;
import org.opentestsystem.ap.ims.model.export.MiExportData;
import org.opentestsystem.ap.ims.model.export.Row;
import org.opentestsystem.ap.ims.model.export.Table;
import org.opentestsystem.ap.ims.model.export.TableAnswer;
import org.opentestsystem.ap.ims.model.export.TableHeader;
import org.springframework.data.util.Pair;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component
public class MiItemContentWriter extends PdfContentWriter implements ItemContentWriter {
    private static final String template = "mi-export";

    @Override
    public boolean supportsItemType(final Item item) {
        return item instanceof MiItem;
    }

    @Override
    public String getHtml(ItemExport itemExport) {

        MiItem item = (MiItem) itemExport.getItem();

        Pair<String, String> promptContent = getPromptContent(itemExport, item);
        AdditionalInfo additionalInfo = AdditionalInfo.create(itemExport);
        TableHolder holder = buildTable(itemExport, item);

        MiExportData exportData = new MiExportData(item.getId(), promptContent.getFirst(), promptContent.getSecond(), additionalInfo, itemExport.isIncludeRubrics(), holder.table, holder.tableAnswers);

        Map<String, Object> data = new HashMap<>();
        data.put("data", exportData);

        String html = convertHtml(template, data, itemExport);

        //TODO - Remove before final commit
        writeHtmlToFile(itemExport, html);

        return html;
    }

    private List<TableHeader> buildTableHeaders(ItemExport itemExport, MiItem item) {
        List<TableHeader> headers = new ArrayList<>();
        List<org.opentestsystem.ap.common.model.Table.Column> englishColumns = item.getCore().getEn().getTable().getColumns();
        List<org.opentestsystem.ap.common.model.Table.Column> spanishColumns = new ArrayList<>();

        if (item.getTranslations() != null && item.getTranslations().getEsp() != null && item.getTranslations().getEsp().getTable() != null) {
            spanishColumns = item.getTranslations().getEsp().getTable().getColumns();
        }

        List<org.opentestsystem.ap.common.model.Table.Column> largerColumnList = englishColumns.size() > spanishColumns.size() ? englishColumns : spanishColumns;

        for (int i = 0; i < largerColumnList.size(); i++) {
            String spanishHeaderText = spanishColumns.size() > i ? spanishColumns.get(i).getLabel() : StringUtils.EMPTY;
            String englishHeaderText = englishColumns.size() > i ? englishColumns.get(i).getLabel() : StringUtils.EMPTY;

            if (StringUtils.isNotBlank(spanishHeaderText) || StringUtils.isNotBlank(englishHeaderText)) {
                TableHeader header = new TableHeader(translateEnglishContent(itemExport, englishHeaderText), translateSpanishContent(itemExport, spanishHeaderText));
                headers.add(header);
            }
        }

        return headers;
    }

    private TableHolder buildTable(ItemExport itemExport, MiItem item) {
        List<Row> rows = new ArrayList<>();
        List<TableAnswer> tableAnswers = new ArrayList<>();
        List<org.opentestsystem.ap.common.model.Table.Row> englishRows = item.getCore().getEn().getTable().getRows();
        List<org.opentestsystem.ap.common.model.Table.Row> spanishRows = new ArrayList<>();

        if (item.getTranslations() != null && item.getTranslations().getEsp() != null && item.getTranslations().getEsp().getTable() != null) {
            spanishRows = item.getTranslations().getEsp().getTable().getRows();
        }

        List<org.opentestsystem.ap.common.model.Table.Row> largerRowList = englishRows.size() > spanishRows.size() ? englishRows : spanishRows;

        /*
         There is no guarantee that rows/cells will be consistent across
         English and Spanish item content
         */
        for (int i = 0; i < largerRowList.size(); i++) {
            int rowNumber = i + 1;
            List<org.opentestsystem.ap.common.model.Table.Cell> spanishCells = spanishRows.size() > i ? spanishRows.get(i).getCells() : new ArrayList<>();
            List<org.opentestsystem.ap.common.model.Table.Cell> englishCells = englishRows.size() > i ? englishRows.get(i).getCells() : new ArrayList<>();

            List<CellHolder> cellHolders = buildCells(itemExport, englishCells, spanishCells);
            List<Cell> cells = new ArrayList<>();

            for (int j = 0; j < cellHolders.size(); j++) {
                cells.add(cellHolders.get(j).cell);

                if (cellHolders.get(j).correctAnswer) {
                    tableAnswers.add(new TableAnswer(rowNumber, j + 1));
                }
            }

            rows.add(new Row(cells));
        }

        return new TableHolder(new Table(buildTableHeaders(itemExport, item), rows), tableAnswers);
    }

    private List<CellHolder> buildCells(ItemExport itemExport, List<org.opentestsystem.ap.common.model.Table.Cell> englishCells, List<org.opentestsystem.ap.common.model.Table.Cell> spanishCells) {
        List<org.opentestsystem.ap.common.model.Table.Cell> largerCellList = englishCells.size() > spanishCells.size() ? englishCells : spanishCells;

        List<CellHolder> outputCells = new ArrayList<>();

        for (int j = 0; j < largerCellList.size(); j++) {
            Cell cell;
            boolean correctAnswer = englishCells.size() > j && englishCells.get(j).isCorrectAnswer();
            String cellType = largerCellList.get(j).getType();
            org.opentestsystem.ap.common.model.Table.Cell englishCell = englishCells.size() > j ? englishCells.get(j) : null;
            org.opentestsystem.ap.common.model.Table.Cell spanishCell = spanishCells.size() > j ? spanishCells.get(j) : null;

            if (ItemConstants.CellType.CELL_TYPE_LABEL.equals(cellType)) {
                String englishText = StringUtils.EMPTY;
                String spanishText = StringUtils.EMPTY;
                if (englishCell != null) {
                    englishText = translateEnglishContent(itemExport, (String) englishCell.getValue());
                }

                if (spanishCell != null) {
                    spanishText = translateSpanishContent(itemExport, (String) spanishCell.getValue());
                }

                cell = new Cell(cellType, englishText, spanishText);
            } else {
                cell = new Cell(cellType);
            }

            outputCells.add(new CellHolder(cell, correctAnswer));
        }

        return outputCells;
    }

    private Pair<String, String> getPromptContent(ItemExport itemExport, MiItem item) {
        String englishContent = translateEnglishContent(itemExport, item.getCore().getEn().getPrompt());

        String spanishContent = StringUtils.EMPTY;
        if (item.getTranslations() != null && item.getTranslations().getEsp() != null) {
            spanishContent = translateSpanishContent(itemExport, item.getTranslations().getEsp().getPrompt());
        }

        return Pair.of(englishContent, spanishContent);
    }

    private static class TableHolder {
        private Table table;
        private List<TableAnswer> tableAnswers;

        TableHolder(final Table table, final List<TableAnswer> tableAnswers) {
            this.table = table;
            this.tableAnswers = tableAnswers;
        }
    }

    private static class CellHolder {
        private Cell cell;
        private boolean correctAnswer;

        CellHolder(final Cell cell, final boolean correctAnswer) {
            this.cell = cell;
            this.correctAnswer = correctAnswer;
        }
    }
}
