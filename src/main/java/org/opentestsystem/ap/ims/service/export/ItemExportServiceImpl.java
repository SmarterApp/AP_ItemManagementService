package org.opentestsystem.ap.ims.service.export;

import com.itextpdf.io.font.constants.StandardFonts;
import com.itextpdf.kernel.font.PdfFont;
import com.itextpdf.kernel.font.PdfFontFactory;
import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.layout.Document;
import com.itextpdf.layout.element.Paragraph;
import lombok.extern.slf4j.Slf4j;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.exception.ValidationException;
import org.opentestsystem.ap.common.model.ItemResponse;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.ims.service.ItemService;
import org.opentestsystem.ap.ims.service.export.writer.ItemContentWriter;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Collection;
import java.util.Optional;
import java.util.UUID;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static com.itextpdf.kernel.events.PdfDocumentEvent.INSERT_PAGE;
import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_TUT;

@Slf4j
@Service
public class ItemExportServiceImpl implements ItemExportService {
    private final ItemService itemService;
    private final Collection<ItemContentWriter> itemContentWriters;
    private final AppAssembler appAssembler;
    private final ItemExportRepository itemExportRepository;

    public ItemExportServiceImpl(final ItemService itemService,
                                 final Collection<ItemContentWriter> itemContentWriters,
                                 final AppAssembler appAssembler,
                                 final ItemExportRepository itemExportRepository) {
        this.itemService = itemService;
        this.itemContentWriters = itemContentWriters;
        this.appAssembler = appAssembler;
        this.itemExportRepository = itemExportRepository;
    }

    @Override
    public Optional<File> exportItem(final String itemId) {
        final ItemResponse itemResponse = itemService.findItem(itemId);

        if (itemResponse.getItem() == null) {
            return Optional.empty();
        } else if (itemResponse.getItem().getType().equals(TYPE_TUT)) {
            throw new ValidationException(TYPE_TUT + " type is not supported");
        }

        try {
            Path path = Files.createTempDirectory(UUID.randomUUID().toString());
            Path clonedItemPath = itemExportRepository.cloneItemForExport(path, itemId);

            ItemRelease itemRelease = getItemRelease(itemId, clonedItemPath);

            File itemFiles = new File(path.toFile(), "itemFiles");
            itemFiles.mkdir();
            File zipFile = new File(path.toFile(), itemId + ".zip");

            createPdf(itemFiles, itemResponse, itemRelease);
            pack(Paths.get(itemFiles.toURI()), Paths.get(zipFile.toURI()));

            return Optional.of(zipFile);
        } catch (IOException ioe) {
            throw new RuntimeException("Unhandled Exception when exporting item", ioe);
        }
    }

    private ItemRelease getItemRelease(final String itemId, final Path itemDirectory) {
        File[] files = itemDirectory.toFile().listFiles((dir, name) -> name.equals(itemId + ".xml"));

        if (files == null || files.length != 1) {
            throw new IllegalStateException("A single item xml should be present for item " + itemId);
        }

        return appAssembler.getSaaifAssembler().readXmlFromFile(files[0].toPath());
    }

    private void createPdf(File directory, ItemResponse itemResponse, ItemRelease itemRelease) throws IOException {
        final String pdfName = itemResponse.getItem().getId() + ".pdf";
        File pdfFile = new File(directory, pdfName);
        pdfFile.createNewFile();

        try (FileOutputStream fos = new FileOutputStream(pdfFile)) {
            PdfWriter writer = new PdfWriter(fos);
            PdfDocument pdf = new PdfDocument(writer);
            Document document = new Document(pdf);
            PdfWriter pdfWriter = new PdfWriter(fos);
            pdf.addEventHandler(INSERT_PAGE, new ItemHeaderListener(itemResponse.getItem().getId(), document));

            PdfFont font = PdfFontFactory.createFont(StandardFonts.TIMES_ROMAN);
            Paragraph paragraph = new Paragraph("Item " + itemRelease.getItem().getId())
                    .setFont(font).setFontSize(24);

            document.add(paragraph);

            for (ItemContentWriter contentWriter : itemContentWriters) {
                if (contentWriter.supportsItemType(itemResponse.getItem())) {
                    contentWriter.addContent(pdfWriter, document, itemResponse.getItem(), itemRelease);
                    break;
                }
            }

            document.close();
        } catch (IOException e) {
            throw new RuntimeException("Unexpected issue creating the pdf", e);
        }
    }

    private static void pack(final Path folder, final Path zipFilePath) throws IOException {
        try (
                FileOutputStream fos = new FileOutputStream(zipFilePath.toFile());
                ZipOutputStream zos = new ZipOutputStream(fos)
        ) {
            Files.walkFileTree(folder, new SimpleFileVisitor<Path>() {
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    zos.putNextEntry(new ZipEntry(folder.relativize(file).toString()));
                    Files.copy(file, zos);
                    zos.closeEntry();
                    return FileVisitResult.CONTINUE;
                }

                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                    zos.putNextEntry(new ZipEntry(folder.relativize(dir).toString() + "/"));
                    zos.closeEntry();
                    return FileVisitResult.CONTINUE;
                }
            });
        }
    }
}
