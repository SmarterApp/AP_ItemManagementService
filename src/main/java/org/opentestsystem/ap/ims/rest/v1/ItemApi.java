/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.rest.v1;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.List;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.QueryParam;

import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.opentestsystem.ap.common.model.ItemDiff;
import org.opentestsystem.ap.common.model.ItemHistory;
import org.opentestsystem.ap.common.model.ItemResponse;
import org.opentestsystem.ap.common.model.ValidationResult;
import org.opentestsystem.ap.common.model.ValidationResults;
import org.opentestsystem.ap.common.util.SystemException;
import org.opentestsystem.ap.ims.entity.WorkflowStatus;
import org.opentestsystem.ap.ims.model.RemoveFile;
import org.opentestsystem.ap.ims.model.UploadFile;
import org.opentestsystem.ap.ims.rest.BeginTransactionRequest;
import org.opentestsystem.ap.ims.rest.EqEditorConfigurationsResponse;
import org.opentestsystem.ap.ims.rest.ItemChangeRequest;
import org.opentestsystem.ap.ims.rest.ItemHistoryResponse;
import org.opentestsystem.ap.ims.service.FileUploadService;
import org.opentestsystem.ap.ims.service.ItemService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_AUDIO;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_IMAGES;

/**
 * Operations on items in the item bank.
 */
@Slf4j
@RestController
@RequestMapping("/api/v1/items")
@Api
public class ItemApi {

    private final String FORMAT_CSV = "csv";

    private final ItemService itemService;

    private final FileUploadService fileUploadService;

    @Autowired
    public ItemApi(final ItemService itemService, final FileUploadService fileUploadService) {
        this.itemService = itemService;
        this.fileUploadService = fileUploadService;
    }

    // ------------------------------------------------------------------------

    /**
     * Finds and returns the item from the item bank.  Returns
     *
     * @param itemId The unique item identifier.
     * @return The item.
     * @{@link org.opentestsystem.ap.common.util.ResourceNotFoundException} if the item is not found.
     */
    @GetMapping("/{itemId}")
    public ItemResponse getItem(@PathVariable final String itemId) {
        log.debug("find item {}", itemId);
        final ItemResponse itemResponse = itemService.findItem(itemId);
        return itemResponse;
    }

    /**
     * The history of an item.
     *
     * @param itemId The unique item identifier.
     * @return The changes associated with an item.
     */
    @GetMapping("/{itemId}/versions")
    public ItemHistoryResponse getItemHistory(@PathVariable final String itemId,
                                              @QueryParam("format") final String format,
                                              final HttpServletResponse response) {
        log.debug("find item {} format {}", itemId, format);
        if (FORMAT_CSV.equalsIgnoreCase(format)) {
            getItemHistoryCsv(itemId, response);
            return null;
        } else {
            final List<ItemHistory> itemHistory = itemService.findItemHistory(itemId);
            return new ItemHistoryResponse(itemHistory);
        }
    }

    /**
     * A list of changes associated with an item.
     *
     * @param itemId The unique item identifier.
     * @return The changes associated with an item.
     */
    @GetMapping("/{itemId}/versions/csv")
    public void getItemHistoryCsv(@PathVariable final String itemId, final HttpServletResponse response) {
        log.debug("find item csv {}", itemId);

        final String csvString = itemService.findItemHistoryCsvString(itemId);

        try (final InputStream csvStream = IOUtils.toInputStream(csvString, "UTF-8")) {
            response.addHeader("Content-disposition", "attachment;filename=item-" + itemId + "-history.csv");
            response.setContentType("text/csv; charset=UTF-8");
            response.setCharacterEncoding("UTF-8");

            // prepend BOM
            IOUtils.write("\ufeff", response.getOutputStream(), "UTF-8");
            IOUtils.copy(csvStream, response.getOutputStream());
            response.flushBuffer();
        } catch (IOException e) {
            throw new SystemException("Error getting CSV for item " + itemId, e);
        }
    }

    /**
     * A list of changes associated with an item.
     *
     * @param itemId The unique item identifier.
     * @return The changes associated with an item.
     */
    @GetMapping("/{itemId}/diff/{historyId}")
    public List<ItemDiff.Diff> getItemDiff(@PathVariable final String itemId,
                                           @PathVariable final String historyId) {
        log.debug("find item {}, historyId {}", itemId, historyId);
        return itemService.findItemDiff(itemId, historyId);
    }

    @GetMapping("/{itemId}/validation")
    public ValidationResults getValidationResults(@PathVariable final String itemId) {
        ValidationResults validationResults = itemService.getValidationResults(itemId);

        // Sort the messages
        List<ValidationResult> results = validationResults.getValidationResults();
        results.sort((x, y) -> {
            int result = x.getMessage().compareToIgnoreCase(y.getMessage());
            return result == 0 ? x.getDetail().compareToIgnoreCase(y.getDetail()) : result;
        });
        validationResults.setValidationResults(results);
        return validationResults;
    }

    @GetMapping("/workflow-statuses")
    public List<WorkflowStatus> getWorkflowStatuses() {
        return itemService.findAllWorkflowStatus();
    }


    @GetMapping("/eq/equation-editor-configurations")
    public EqEditorConfigurationsResponse getEqEditorConfigurations() {
        return new EqEditorConfigurationsResponse(itemService.findAllEquationEditorConfigurations());
    }

    // ------------------------------------------------------------------------
    // POST requests - Create Item
    // ------------------------------------------------------------------------

    /**
     * Creates an item in the item bank.  The create can be canceled.  When canceled the item is deleted from the item
     * bank.
     *
     * @return The item.
     */
    @PostMapping("/transactions")
    public ItemResponse beginCreateTransaction(@RequestBody final BeginTransactionRequest request) {
        log.debug("create new item");
        return itemService.beginCreateTransaction(request.getType(), request.getMessage());
    }

    /**
     * Starts an edit transaction on an item.  The section is locked for editing by the requesting user. Section edits
     * can be rolled back. The changes while editing are undone.
     *
     * @param itemId The item the edit transaction is started for.
     * @return The item.
     */
    @PostMapping("/{itemId}/transactions/{section}")
    public ItemResponse beginEditTransaction(@PathVariable final String itemId,
                                             @PathVariable final String section,
                                             @RequestBody final BeginTransactionRequest request) {
        log.debug("begin editing item {}", itemId);
        return itemService.beginEditTransaction(itemId, section, request.getMessage());
    }

    /**
     * Saves changes made to the item.
     *
     * @param itemId            The item to save.
     * @param itemChangeRequest The changes to save.
     */
    @PatchMapping("/{itemId}")
    public void saveTransaction(@PathVariable final String itemId,
                                @RequestBody final ItemChangeRequest itemChangeRequest) {
        log.debug("save edits for item {}", itemId);
        itemService.saveTransaction(itemId, itemChangeRequest);
    }

    /**
     * Merge the section edits to the master branch.
     *
     * @param itemId            The item's unique identifier.
     * @param itemChangeRequest The changes to save.
     */
    @PutMapping("/{itemId}/transactions")
    public void commitTransaction(@PathVariable final String itemId,
                                  @RequestBody final ItemChangeRequest itemChangeRequest) {
        log.debug("commit new item {}", itemId);
        itemService.commitTransaction(itemId, itemChangeRequest);
    }

    /**
     * Attaches a file to the item.
     *
     * @param itemId The item to delete.
     */
    @DeleteMapping("/{itemId}/transactions")
    public void rollbackTransaction(@PathVariable final String itemId) {
        log.debug("delete new item {}", itemId);
        itemService.rollbackTransaction(itemId);
    }

    // ------------------------------------------------------------------------

    /**
     * Attaches a file to the item.
     *
     * @param uploadFile The file data.
     */
    @PostMapping("/{itemId}/files/{section}")
    public void attachFile(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading file");
        fileUploadService.attachFile(uploadFile);
    }

    /**
     * Attaches an audio file to the item.
     *
     * @param uploadFile The audio file data.
     */
    @PostMapping("/{itemId}/files/audio/{resourceId}/{target}")
    public void attachAudioFile(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading audio file");
        uploadFile.setSection(SECTION_AUDIO);
        fileUploadService.attachFile(uploadFile);
    }

    /**
     * Attaches an audio file to the item.
     *
     * @param uploadFile The audio file data.
     */
    @PostMapping("/{itemId}/files/images/{resourceId}/{target}")
    public void attachImagesFile(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading audio file");
        uploadFile.setSection(SECTION_IMAGES);
        fileUploadService.attachFile(uploadFile);
    }

    /**
     * Deletes a file associated with the item.
     *
     * @param removeFile The file data to remove from an item.
     */
    @DeleteMapping("/{itemId}/files/{fileName:.+}")
    public void detachFile(@ModelAttribute final RemoveFile removeFile) {
        log.debug("Deleting file");
        fileUploadService.detachFile(removeFile);
    }

//    /**
//     * Deletes a file associated with the item.
//     *
//     * @param removeFile The file data to remove from an item.
//     */
//    @DeleteMapping("/{itemId}/files/{section}/{fileName:.+}")
//    public void detachFile(@ModelAttribute final RemoveFile removeFile) {
//        log.debug("Deleting file");
//        fileUploadService.detachFile(removeFile);
//    }
//
//    /**
//     * Deletes a file associated with the item.
//     *
//     * @param removeFile The file data to remove from an item.
//     */
//    @DeleteMapping("/{itemId}/files/audio/{resourceId}/{target}/{fileName:.+}")
//    public void detachAudioFile(@ModelAttribute final RemoveFile removeFile) {
//        log.debug("Deleting file");
//        removeFile.setSection(SECTION_AUDIO);
//        fileUploadService.detachFile(removeFile);
//    }
//
//    /**
//     * Deletes a file associated with the item.
//     *
//     * @param removeFile The file data to remove from an item.
//     */
//    @DeleteMapping("/{itemId}/files/images/{resourceId}/{target}/{fileName:.+}")
//    public void detachImagesFile(@ModelAttribute final RemoveFile removeFile) {
//        log.debug("Deleting file");
//        removeFile.setSection(SECTION_IMAGES);
//        fileUploadService.detachFile(removeFile);
//    }

    /**
     * Returns the requested file.
     *
     * @param itemId   The unique item ID.
     * @param fileName The name of the file to download.
     */
    @GetMapping("/{itemId}/files/{fileName:.+}")
    public void getAttachedFile(@PathVariable final String itemId,
                                @PathVariable final String fileName,
                                final HttpServletResponse response) {
        log.debug("Uploading file");
        final Path filePath = itemService.getfilePath(itemId, fileName);

        try (final InputStream fileStream = FileUtils.openInputStream(filePath.toFile())) {

            response.addHeader("Content-disposition", "attachment;filename=" + fileName);
            response.setContentType("text/plain; charset=UTF-8");
            response.setCharacterEncoding("UTF-8");

            IOUtils.copy(fileStream, response.getOutputStream());
            response.flushBuffer();

            // the file is within the item folder which is within a random folder
            itemService.deleteLocalRepo(filePath.getParent().getParent());
        } catch (IOException e) {
            throw new SystemException("Error getting file " + fileName, e);
        }
    }

}
