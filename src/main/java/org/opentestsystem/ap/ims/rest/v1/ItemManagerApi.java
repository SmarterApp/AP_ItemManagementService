/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.rest.v1;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.IOUtils;
import org.opentestsystem.ap.common.exception.ResourceNotFoundException;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.model.ItemDiff;
import org.opentestsystem.ap.common.model.ItemHistory;
import org.opentestsystem.ap.common.model.ItemResponse;
import org.opentestsystem.ap.common.model.WorkflowStatus;
import org.opentestsystem.ap.common.model.WorkflowStatusTransition;
import org.opentestsystem.ap.common.model.eqconfig.EqEquationEditorConfiguration;
import org.opentestsystem.ap.ims.model.UploadFile;
import org.opentestsystem.ap.ims.rest.BeginTransactionRequest;
import org.opentestsystem.ap.ims.rest.ItemChangeRequest;
import org.opentestsystem.ap.ims.rest.ItemHistoryResponse;
import org.opentestsystem.ap.ims.service.AttachmentService;
import org.opentestsystem.ap.ims.service.ItemManagerService;
import org.opentestsystem.ap.ims.service.export.ItemExportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.QueryParam;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;

import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_AUDIO;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_GLOSSARY;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_IMAGES;

/**
 * Operations on items in the item bank.
 */
@Slf4j
@RestController
@RequestMapping("/api/v1/items")
public class ItemManagerApi {

    private final String FORMAT_CSV = "csv";

    private final ItemManagerService itemManagerService;

    private final AttachmentService attachmentService;

    private final ItemExportService itemExportService;

    @Autowired
    public ItemManagerApi(final ItemManagerService itemManagerService,
                          final AttachmentService attachmentService,
                          final ItemExportService itemExportService) {
        this.itemManagerService = itemManagerService;
        this.attachmentService = attachmentService;
        this.itemExportService = itemExportService;
    }

    // ------------------------------------------------------------------------

    /**
     * Finds and returns the item from the item bank.  Returns
     *
     * @param itemId The unique item identifier.
     * @return The item.
     * @{@link org.opentestsystem.ap.common.util.ResourceNotFoundException} if the item is not found.
     */
    @GetMapping("/{itemId}")
    public ItemResponse getItem(@PathVariable final String itemId) {
        log.trace("find item {}", itemId);
        final ItemResponse itemResponse = itemManagerService.findItem(itemId);
        return itemResponse;
    }

    /**
     * The history of an item.
     *
     * @param itemId The unique item identifier.
     * @return The changes associated with an item.
     */
    @GetMapping("/{itemId}/versions")
    public ItemHistoryResponse getItemHistory(@PathVariable final String itemId,
                                              @QueryParam("format") final String format,
                                              final HttpServletResponse response) {
        log.debug("find item {} format {}", itemId, format);
        if (FORMAT_CSV.equalsIgnoreCase(format)) {
            getItemHistoryCsv(itemId, response);
            return null;
        } else {
            final List<ItemHistory> itemHistory = itemManagerService.findItemHistory(itemId);
            return new ItemHistoryResponse(itemHistory);
        }
    }

    /**
     * A list of changes associated with an item.
     *
     * @param itemId The unique item identifier.
     * @return The changes associated with an item.
     */
    @GetMapping("/{itemId}/versions/csv")
    public void getItemHistoryCsv(@PathVariable final String itemId, final HttpServletResponse response) {
        log.debug("find item csv {}", itemId);

        final String csvString = itemManagerService.findItemHistoryCsvString(itemId);

        try (final InputStream csvStream = IOUtils.toInputStream(csvString, "UTF-8")) {
            response.addHeader("Content-disposition", "attachment;filename=item-" + itemId + "-history.csv");
            response.setContentType("text/csv; charset=UTF-8");
            response.setCharacterEncoding("UTF-8");

            // prepend BOM
            IOUtils.write("\ufeff", response.getOutputStream(), "UTF-8");
            IOUtils.copy(csvStream, response.getOutputStream());
            response.flushBuffer();
        } catch (IOException e) {
            throw new SystemException("Error getting CSV for item " + itemId, e);
        }
    }

    /**
     * A list of changes associated with an item.
     *
     * @param itemId The unique item identifier.
     * @return The changes associated with an item.
     */
    @GetMapping("/{itemId}/diff/{historyId}")
    public List<ItemDiff.Diff> getItemDiff(@PathVariable final String itemId,
                                           @PathVariable final String historyId) {
        log.debug("find item {}, historyId {}", itemId, historyId);
        return itemManagerService.findItemDiff(itemId, historyId);
    }

    /**
     * @return
     */
    @GetMapping("/workflow-statuses")
    public List<WorkflowStatus> getWorkflowStatuses() {
        return itemManagerService.findAllWorkflowStatus();
    }

    /**
     *
     * @param currentStatusCode
     * @return
     */
    @GetMapping("/workflow-statuses/{currentStatusCode}")
    public List<WorkflowStatusTransition> getAllowedWorkflowStatuses(@PathVariable final String currentStatusCode) {
        return itemManagerService.findAllowedWorkflowStatuses(currentStatusCode);
    }

    /**
     * @return
     */
    @GetMapping("/eq/equation-editor-configurations")
    public List<EqEquationEditorConfiguration> getEqEditorConfigurations() {
        return itemManagerService.findAllEquationEditorConfigurations();
    }

    // ------------------------------------------------------------------------
    // POST requests - Create Item
    // ------------------------------------------------------------------------

    /**
     * Creates an item in the item bank.  The create can be canceled.  When canceled the item is deleted from the item
     * bank.
     *
     * @return The item.
     */
    @PostMapping("/transactions")
    public ItemResponse beginCreateTransaction(@RequestBody final BeginTransactionRequest request) {
        log.debug("create new item");
        return itemManagerService.beginCreateTransaction(request.getType(), request.getMessage());
    }

    /**
     * Starts an edit transaction on an item.  The section is locked for editing by the requesting user. Section edits
     * can be rolled back. The changes while editing are undone.
     *
     * @param itemId The item the edit transaction is started for.
     * @return The item.
     */
    @PostMapping("/{itemId}/transactions/{section}")
    public ItemResponse beginEditTransaction(@PathVariable final String itemId,
                                             @PathVariable final String section,
                                             @RequestBody final BeginTransactionRequest request) {
        log.debug("begin editing item {}", itemId);
        return itemManagerService.beginEditTransaction(itemId, section, request.getMessage());
    }

    /**
     * Saves changes made to the item.
     *
     * @param itemId            The item to save.
     * @param itemChangeRequest The changes to save.
     */
    @PatchMapping("/{itemId}")
    public void saveTransaction(@PathVariable final String itemId,
                                @RequestBody final ItemChangeRequest itemChangeRequest) {
        log.debug("save edits for item {}", itemId);
        itemManagerService.saveTransaction(itemId, itemChangeRequest);
    }

    /**
     * Merge the section edits to the master branch.
     *
     * @param itemId            The item's unique identifier.
     * @param itemChangeRequest The changes to save.
     */
    @PutMapping("/{itemId}/transactions")
    public void commitTransaction(@PathVariable final String itemId,
                                  @RequestBody final ItemChangeRequest itemChangeRequest) {
        log.debug("commit new item {}", itemId);
        itemManagerService.commitTransaction(itemId, itemChangeRequest);
    }

    /**
     * Merge the section edits to the master branch.
     *
     * @param itemId            The item's unique identifier.
     * @param itemChangeRequest The changes to save.
     */
    @PatchMapping("/{itemId}/fields/{fieldPath:.+}")
    public void commitFieldChange(@PathVariable final String itemId,
                                  @PathVariable final String fieldPath,
                                  @RequestBody final ItemChangeRequest itemChangeRequest) {
        log.debug("commit field change for item {} and field {}", itemId, fieldPath);
        itemManagerService.commitFieldChange(itemId, fieldPath, itemChangeRequest);
    }

    /**
     * Attaches a file to the item.
     *
     * @param itemId The item to delete.
     */
    @DeleteMapping("/{itemId}/transactions")
    public void rollbackTransaction(@PathVariable final String itemId) {
        log.debug("delete new item {}", itemId);
        itemManagerService.rollbackTransaction(itemId);
    }

    // ------------------------------------------------------------------------
    // Read file and return contents as a string
    // ------------------------------------------------------------------------

    /**
     * @param uploadFile
     * @return
     */
    @PostMapping("/bulkpreview/file")
    public String readDashboardFile(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Reading Dashboard Upload file");
        return attachmentService.convertBulkPreviewFile(uploadFile);
    }

    @PostMapping("/file/read-contents")
    public String readFileContents(@ModelAttribute final UploadFile uploadFile) {
        return attachmentService.readFileContents(uploadFile);
    }

    // ------------------------------------------------------------------------
    // Attach files to an item
    // ------------------------------------------------------------------------

    /**
     * @param uploadFile The uploaded file and associated data.
     */
    @PostMapping("/{itemId}/{itemType}/files/{section}")
    public void attachFileWithType(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading file");
        attachmentService.saveAttachment(uploadFile);
    }

    /**
     * Attaches a file to the item.
     *
     * @param uploadFile The file data.
     */
    @PostMapping("/{itemId}/files/{section}")
    public void attachFile(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading file");
        attachmentService.saveAttachment(uploadFile);
    }

    /**
     * Attaches an audio file to the item.
     *
     * @param uploadFile The audio file data.
     */
    @PostMapping("/{itemId}/files/audio/{resourceId}/{target}")
    public void attachAudioFile(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading audio file");
        uploadFile.setSection(SECTION_AUDIO);
        attachmentService.saveAttachment(uploadFile);
    }

    /**
     * Attaches an audio file to the item.
     *
     * @param uploadFile The audio file data.
     */
    @PostMapping("/{itemId}/files/images/{resourceId}/{target}")
    public void attachImagesFile(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading audio file");
        uploadFile.setSection(SECTION_IMAGES);
        attachmentService.saveAttachment(uploadFile);
    }

    /**
     * Attaches a glossary audio file to the item.
     *
     * @param uploadFile
     */
    @PostMapping("/{itemId}/files/glossary/{termId}/{languageId}/{dialectId}")
    public void attachGlossaryFile(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading glossary file");
        uploadFile.setSection(SECTION_GLOSSARY);
        attachmentService.saveAttachment(uploadFile);
    }

    /**
     * Bulk updates Test Administration data for multiple items.
     *
     * @param uploadFile
     */
    @PostMapping("/files/testadmin")
    public void processTestAdminstration(@ModelAttribute final UploadFile uploadFile) {
        log.debug("Uploading Test Administration data");
        attachmentService.processTestAdministrationData(uploadFile);
    }

    /**
     * Returns the requested file.
     *
     * @param itemId   The unique item ID.
     * @param fileName The name of the file to download.
     */
    @GetMapping("/{itemId}/files/{fileName:.+}")
    public void getAttachedFile(@PathVariable final String itemId,
                                @PathVariable final String fileName,
                                @RequestParam final Optional<String> folder,
                                @RequestParam final Optional<String> filePrefix,
                                final HttpServletResponse response) {
        log.debug("Downloading file {} for item {}", fileName, itemId);

        Function<String, String> attachPrefix = prefix -> String.format("%s_%s", prefix, fileName);

        // glossary attachments have a prefix
        String repoFileName = filePrefix.map(attachPrefix).orElse(fileName);
        // general-attachments and glossary are stored in folders
        repoFileName = folder.isPresent() ? String.format("%s/%s", folder.get(), repoFileName) : repoFileName;

        try (final InputStream fileStream = attachmentService.getAttachment(itemId, repoFileName)) {
            response.addHeader("Content-disposition", "attachment;filename=" + fileName);
            response.setContentType("text/plain; charset=UTF-8");
            response.setCharacterEncoding("UTF-8");

            IOUtils.copy(fileStream, response.getOutputStream());
            response.flushBuffer();
        } catch (IOException e) {
            throw new SystemException("Error getting file " + fileName, e);
        }
    }

    @GetMapping("/{itemId}/resources/{section}")
    public List<String> findAttachments(@PathVariable final String itemId, @PathVariable final String section) {
        return this.attachmentService.findAttachments(itemId, section);
    }

    /**
     * Exports an item and its contents
     *
     * @param itemId the item's id
     * @return response with archive file resource
     */
    @GetMapping(value = "/{itemId}/export", produces = "application/zip")
    @ResponseBody
    public ResponseEntity<FileSystemResource> exportItem(@PathVariable("itemId") String itemId, @RequestParam(required = false) boolean includeRubrics) {
        Optional<File> maybeExport = itemExportService.exportItem(itemId, includeRubrics);

        if (!maybeExport.isPresent()) {
            throw new ResourceNotFoundException("Could not find item " + itemId);
        }

        FileSystemResource resource = new FileSystemResource(maybeExport.get());
        return ResponseEntity
                .ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
                .body(resource);
    }
}
